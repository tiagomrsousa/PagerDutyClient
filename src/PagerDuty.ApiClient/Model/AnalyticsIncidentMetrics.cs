/* 
 * PagerDuty API
 *
 * This document describes the PagerDuty REST APIs.  For guides and examples please visit our [Documentation.](https://developer.pagerduty.com/docs/get-started/getting-started/)  Our REST APIs are defined in OpenAPI v3.x. You can view the schema at [github.com/PagerDuty/api-schema](https://github.com/PagerDuty/api-schema).  Note that properties in some schemas have fields not shown by default such as `readOnly`, `format`, and `default`. Hover your cursor over the right column that looks like `optional+1` to see the full list of fields. 
 *
 * OpenAPI spec version: 2.0.0
 * Contact: support@pagerduty.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = PagerDuty.ApiClient.Client.SwaggerDateConverter;

namespace PagerDuty.ApiClient.Model
{
    /// <summary>
    /// AnalyticsIncidentMetrics
    /// </summary>
    [DataContract]
        public partial class AnalyticsIncidentMetrics :  IEquatable<AnalyticsIncidentMetrics>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AnalyticsIncidentMetrics" /> class.
        /// </summary>
        /// <param name="meanAssignmentCount">Mean count of instances where responders were assigned an incident (including through reassignment or escalation) or accepted a responder request..</param>
        /// <param name="meanEngagedSeconds">Mean engaged time across all responders for incidents that match the given filters. Engaged time is measured from the time a user engages with an incident (by acknowledging or accepting a responder request) until the incident is resolved. This may include periods in which the incidents was snoozed..</param>
        /// <param name="meanEngagedUserCount">Mean number of users who engaged with an incident. *Engaged* is defined as acknowledging an incident or accepting a responder request in it..</param>
        /// <param name="meanSecondsToEngage">A measure of *people response time*. This metric measures the time from the first user engagement (acknowledge or responder accept) to the last. This metric is only used for incidents with **multiple responders**; for incidents with one or no engaged users, this value is null..</param>
        /// <param name="meanSecondsToFirstAck">Mean time between the start of an incident, and the first responder to acknowledge..</param>
        /// <param name="meanSecondsToMobilize">Mean time between the start of an incident, and the last additional responder to acknowledge. For incidents with one or no engaged users, this value is null..</param>
        /// <param name="meanSecondsToResolve">Mean time from when an incident was triggered until it was resolved..</param>
        /// <param name="serviceId">ID of the service. Only included when aggregating by service..</param>
        /// <param name="serviceName">Name of the service. Only included when aggregating by service..</param>
        /// <param name="teamId">ID of the team the incident was assigned to..</param>
        /// <param name="teamName">Name of the team the incident was assigned to..</param>
        /// <param name="totalBusinessHourInterruptions">Total number of unique interruptions during business hours. Business hour: 8am-6pm Mon-Fri, based on the user’s time zone. .</param>
        /// <param name="totalEngagedSeconds">Total engaged time across all responders for incidents. Engaged time is measured from the time a user engages with an incident (by acknowledging or accepting a responder request) until the incident is resolved. This may include periods in which the incidents was snoozed..</param>
        /// <param name="totalEscalationCount">Total count of instances where an incident is escalated between responders assigned to an escalation policy..</param>
        /// <param name="totalIncidentCount">The total number of incidents that were created..</param>
        /// <param name="totalOffHourInterruptions">Total number of unique interruptions during off hours. Off hour: 6pm-10pm Mon-Fri and all day Sat-Sun, based on the user’s time zone..</param>
        /// <param name="totalSleepHourInterruptions">Total number of unique interruptions during sleep hours. Sleep hour: 10pm-8am every day, based on the user’s time zone..</param>
        /// <param name="totalSnoozedSeconds">Total number of seconds incidents were snoozed..</param>
        /// <param name="upTimePct">The percentage of time in the defined date range that the service was not interrupted by a [major incident](https://support.pagerduty.com/docs/operational-reviews#major-incidents)..</param>
        public AnalyticsIncidentMetrics(int? meanAssignmentCount = default(int?), int? meanEngagedSeconds = default(int?), int? meanEngagedUserCount = default(int?), int? meanSecondsToEngage = default(int?), int? meanSecondsToFirstAck = default(int?), int? meanSecondsToMobilize = default(int?), int? meanSecondsToResolve = default(int?), string serviceId = default(string), string serviceName = default(string), string teamId = default(string), string teamName = default(string), int? totalBusinessHourInterruptions = default(int?), int? totalEngagedSeconds = default(int?), int? totalEscalationCount = default(int?), int? totalIncidentCount = default(int?), int? totalOffHourInterruptions = default(int?), int? totalSleepHourInterruptions = default(int?), int? totalSnoozedSeconds = default(int?), decimal? upTimePct = default(decimal?))
        {
            this.MeanAssignmentCount = meanAssignmentCount;
            this.MeanEngagedSeconds = meanEngagedSeconds;
            this.MeanEngagedUserCount = meanEngagedUserCount;
            this.MeanSecondsToEngage = meanSecondsToEngage;
            this.MeanSecondsToFirstAck = meanSecondsToFirstAck;
            this.MeanSecondsToMobilize = meanSecondsToMobilize;
            this.MeanSecondsToResolve = meanSecondsToResolve;
            this.ServiceId = serviceId;
            this.ServiceName = serviceName;
            this.TeamId = teamId;
            this.TeamName = teamName;
            this.TotalBusinessHourInterruptions = totalBusinessHourInterruptions;
            this.TotalEngagedSeconds = totalEngagedSeconds;
            this.TotalEscalationCount = totalEscalationCount;
            this.TotalIncidentCount = totalIncidentCount;
            this.TotalOffHourInterruptions = totalOffHourInterruptions;
            this.TotalSleepHourInterruptions = totalSleepHourInterruptions;
            this.TotalSnoozedSeconds = totalSnoozedSeconds;
            this.UpTimePct = upTimePct;
        }
        
        /// <summary>
        /// Mean count of instances where responders were assigned an incident (including through reassignment or escalation) or accepted a responder request.
        /// </summary>
        /// <value>Mean count of instances where responders were assigned an incident (including through reassignment or escalation) or accepted a responder request.</value>
        [DataMember(Name="mean_assignment_count", EmitDefaultValue=false)]
        public int? MeanAssignmentCount { get; set; }

        /// <summary>
        /// Mean engaged time across all responders for incidents that match the given filters. Engaged time is measured from the time a user engages with an incident (by acknowledging or accepting a responder request) until the incident is resolved. This may include periods in which the incidents was snoozed.
        /// </summary>
        /// <value>Mean engaged time across all responders for incidents that match the given filters. Engaged time is measured from the time a user engages with an incident (by acknowledging or accepting a responder request) until the incident is resolved. This may include periods in which the incidents was snoozed.</value>
        [DataMember(Name="mean_engaged_seconds", EmitDefaultValue=false)]
        public int? MeanEngagedSeconds { get; set; }

        /// <summary>
        /// Mean number of users who engaged with an incident. *Engaged* is defined as acknowledging an incident or accepting a responder request in it.
        /// </summary>
        /// <value>Mean number of users who engaged with an incident. *Engaged* is defined as acknowledging an incident or accepting a responder request in it.</value>
        [DataMember(Name="mean_engaged_user_count", EmitDefaultValue=false)]
        public int? MeanEngagedUserCount { get; set; }

        /// <summary>
        /// A measure of *people response time*. This metric measures the time from the first user engagement (acknowledge or responder accept) to the last. This metric is only used for incidents with **multiple responders**; for incidents with one or no engaged users, this value is null.
        /// </summary>
        /// <value>A measure of *people response time*. This metric measures the time from the first user engagement (acknowledge or responder accept) to the last. This metric is only used for incidents with **multiple responders**; for incidents with one or no engaged users, this value is null.</value>
        [DataMember(Name="mean_seconds_to_engage", EmitDefaultValue=false)]
        public int? MeanSecondsToEngage { get; set; }

        /// <summary>
        /// Mean time between the start of an incident, and the first responder to acknowledge.
        /// </summary>
        /// <value>Mean time between the start of an incident, and the first responder to acknowledge.</value>
        [DataMember(Name="mean_seconds_to_first_ack", EmitDefaultValue=false)]
        public int? MeanSecondsToFirstAck { get; set; }

        /// <summary>
        /// Mean time between the start of an incident, and the last additional responder to acknowledge. For incidents with one or no engaged users, this value is null.
        /// </summary>
        /// <value>Mean time between the start of an incident, and the last additional responder to acknowledge. For incidents with one or no engaged users, this value is null.</value>
        [DataMember(Name="mean_seconds_to_mobilize", EmitDefaultValue=false)]
        public int? MeanSecondsToMobilize { get; set; }

        /// <summary>
        /// Mean time from when an incident was triggered until it was resolved.
        /// </summary>
        /// <value>Mean time from when an incident was triggered until it was resolved.</value>
        [DataMember(Name="mean_seconds_to_resolve", EmitDefaultValue=false)]
        public int? MeanSecondsToResolve { get; set; }

        /// <summary>
        /// ID of the service. Only included when aggregating by service.
        /// </summary>
        /// <value>ID of the service. Only included when aggregating by service.</value>
        [DataMember(Name="service_id", EmitDefaultValue=false)]
        public string ServiceId { get; set; }

        /// <summary>
        /// Name of the service. Only included when aggregating by service.
        /// </summary>
        /// <value>Name of the service. Only included when aggregating by service.</value>
        [DataMember(Name="service_name", EmitDefaultValue=false)]
        public string ServiceName { get; set; }

        /// <summary>
        /// ID of the team the incident was assigned to.
        /// </summary>
        /// <value>ID of the team the incident was assigned to.</value>
        [DataMember(Name="team_id", EmitDefaultValue=false)]
        public string TeamId { get; set; }

        /// <summary>
        /// Name of the team the incident was assigned to.
        /// </summary>
        /// <value>Name of the team the incident was assigned to.</value>
        [DataMember(Name="team_name", EmitDefaultValue=false)]
        public string TeamName { get; set; }

        /// <summary>
        /// Total number of unique interruptions during business hours. Business hour: 8am-6pm Mon-Fri, based on the user’s time zone. 
        /// </summary>
        /// <value>Total number of unique interruptions during business hours. Business hour: 8am-6pm Mon-Fri, based on the user’s time zone. </value>
        [DataMember(Name="total_business_hour_interruptions", EmitDefaultValue=false)]
        public int? TotalBusinessHourInterruptions { get; set; }

        /// <summary>
        /// Total engaged time across all responders for incidents. Engaged time is measured from the time a user engages with an incident (by acknowledging or accepting a responder request) until the incident is resolved. This may include periods in which the incidents was snoozed.
        /// </summary>
        /// <value>Total engaged time across all responders for incidents. Engaged time is measured from the time a user engages with an incident (by acknowledging or accepting a responder request) until the incident is resolved. This may include periods in which the incidents was snoozed.</value>
        [DataMember(Name="total_engaged_seconds", EmitDefaultValue=false)]
        public int? TotalEngagedSeconds { get; set; }

        /// <summary>
        /// Total count of instances where an incident is escalated between responders assigned to an escalation policy.
        /// </summary>
        /// <value>Total count of instances where an incident is escalated between responders assigned to an escalation policy.</value>
        [DataMember(Name="total_escalation_count", EmitDefaultValue=false)]
        public int? TotalEscalationCount { get; set; }

        /// <summary>
        /// The total number of incidents that were created.
        /// </summary>
        /// <value>The total number of incidents that were created.</value>
        [DataMember(Name="total_incident_count", EmitDefaultValue=false)]
        public int? TotalIncidentCount { get; set; }

        /// <summary>
        /// Total number of unique interruptions during off hours. Off hour: 6pm-10pm Mon-Fri and all day Sat-Sun, based on the user’s time zone.
        /// </summary>
        /// <value>Total number of unique interruptions during off hours. Off hour: 6pm-10pm Mon-Fri and all day Sat-Sun, based on the user’s time zone.</value>
        [DataMember(Name="total_off_hour_interruptions", EmitDefaultValue=false)]
        public int? TotalOffHourInterruptions { get; set; }

        /// <summary>
        /// Total number of unique interruptions during sleep hours. Sleep hour: 10pm-8am every day, based on the user’s time zone.
        /// </summary>
        /// <value>Total number of unique interruptions during sleep hours. Sleep hour: 10pm-8am every day, based on the user’s time zone.</value>
        [DataMember(Name="total_sleep_hour_interruptions", EmitDefaultValue=false)]
        public int? TotalSleepHourInterruptions { get; set; }

        /// <summary>
        /// Total number of seconds incidents were snoozed.
        /// </summary>
        /// <value>Total number of seconds incidents were snoozed.</value>
        [DataMember(Name="total_snoozed_seconds", EmitDefaultValue=false)]
        public int? TotalSnoozedSeconds { get; set; }

        /// <summary>
        /// The percentage of time in the defined date range that the service was not interrupted by a [major incident](https://support.pagerduty.com/docs/operational-reviews#major-incidents).
        /// </summary>
        /// <value>The percentage of time in the defined date range that the service was not interrupted by a [major incident](https://support.pagerduty.com/docs/operational-reviews#major-incidents).</value>
        [DataMember(Name="up_time_pct", EmitDefaultValue=false)]
        public decimal? UpTimePct { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class AnalyticsIncidentMetrics {\n");
            sb.Append("  MeanAssignmentCount: ").Append(MeanAssignmentCount).Append("\n");
            sb.Append("  MeanEngagedSeconds: ").Append(MeanEngagedSeconds).Append("\n");
            sb.Append("  MeanEngagedUserCount: ").Append(MeanEngagedUserCount).Append("\n");
            sb.Append("  MeanSecondsToEngage: ").Append(MeanSecondsToEngage).Append("\n");
            sb.Append("  MeanSecondsToFirstAck: ").Append(MeanSecondsToFirstAck).Append("\n");
            sb.Append("  MeanSecondsToMobilize: ").Append(MeanSecondsToMobilize).Append("\n");
            sb.Append("  MeanSecondsToResolve: ").Append(MeanSecondsToResolve).Append("\n");
            sb.Append("  ServiceId: ").Append(ServiceId).Append("\n");
            sb.Append("  ServiceName: ").Append(ServiceName).Append("\n");
            sb.Append("  TeamId: ").Append(TeamId).Append("\n");
            sb.Append("  TeamName: ").Append(TeamName).Append("\n");
            sb.Append("  TotalBusinessHourInterruptions: ").Append(TotalBusinessHourInterruptions).Append("\n");
            sb.Append("  TotalEngagedSeconds: ").Append(TotalEngagedSeconds).Append("\n");
            sb.Append("  TotalEscalationCount: ").Append(TotalEscalationCount).Append("\n");
            sb.Append("  TotalIncidentCount: ").Append(TotalIncidentCount).Append("\n");
            sb.Append("  TotalOffHourInterruptions: ").Append(TotalOffHourInterruptions).Append("\n");
            sb.Append("  TotalSleepHourInterruptions: ").Append(TotalSleepHourInterruptions).Append("\n");
            sb.Append("  TotalSnoozedSeconds: ").Append(TotalSnoozedSeconds).Append("\n");
            sb.Append("  UpTimePct: ").Append(UpTimePct).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as AnalyticsIncidentMetrics);
        }

        /// <summary>
        /// Returns true if AnalyticsIncidentMetrics instances are equal
        /// </summary>
        /// <param name="input">Instance of AnalyticsIncidentMetrics to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(AnalyticsIncidentMetrics input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.MeanAssignmentCount == input.MeanAssignmentCount ||
                    (this.MeanAssignmentCount != null &&
                    this.MeanAssignmentCount.Equals(input.MeanAssignmentCount))
                ) && 
                (
                    this.MeanEngagedSeconds == input.MeanEngagedSeconds ||
                    (this.MeanEngagedSeconds != null &&
                    this.MeanEngagedSeconds.Equals(input.MeanEngagedSeconds))
                ) && 
                (
                    this.MeanEngagedUserCount == input.MeanEngagedUserCount ||
                    (this.MeanEngagedUserCount != null &&
                    this.MeanEngagedUserCount.Equals(input.MeanEngagedUserCount))
                ) && 
                (
                    this.MeanSecondsToEngage == input.MeanSecondsToEngage ||
                    (this.MeanSecondsToEngage != null &&
                    this.MeanSecondsToEngage.Equals(input.MeanSecondsToEngage))
                ) && 
                (
                    this.MeanSecondsToFirstAck == input.MeanSecondsToFirstAck ||
                    (this.MeanSecondsToFirstAck != null &&
                    this.MeanSecondsToFirstAck.Equals(input.MeanSecondsToFirstAck))
                ) && 
                (
                    this.MeanSecondsToMobilize == input.MeanSecondsToMobilize ||
                    (this.MeanSecondsToMobilize != null &&
                    this.MeanSecondsToMobilize.Equals(input.MeanSecondsToMobilize))
                ) && 
                (
                    this.MeanSecondsToResolve == input.MeanSecondsToResolve ||
                    (this.MeanSecondsToResolve != null &&
                    this.MeanSecondsToResolve.Equals(input.MeanSecondsToResolve))
                ) && 
                (
                    this.ServiceId == input.ServiceId ||
                    (this.ServiceId != null &&
                    this.ServiceId.Equals(input.ServiceId))
                ) && 
                (
                    this.ServiceName == input.ServiceName ||
                    (this.ServiceName != null &&
                    this.ServiceName.Equals(input.ServiceName))
                ) && 
                (
                    this.TeamId == input.TeamId ||
                    (this.TeamId != null &&
                    this.TeamId.Equals(input.TeamId))
                ) && 
                (
                    this.TeamName == input.TeamName ||
                    (this.TeamName != null &&
                    this.TeamName.Equals(input.TeamName))
                ) && 
                (
                    this.TotalBusinessHourInterruptions == input.TotalBusinessHourInterruptions ||
                    (this.TotalBusinessHourInterruptions != null &&
                    this.TotalBusinessHourInterruptions.Equals(input.TotalBusinessHourInterruptions))
                ) && 
                (
                    this.TotalEngagedSeconds == input.TotalEngagedSeconds ||
                    (this.TotalEngagedSeconds != null &&
                    this.TotalEngagedSeconds.Equals(input.TotalEngagedSeconds))
                ) && 
                (
                    this.TotalEscalationCount == input.TotalEscalationCount ||
                    (this.TotalEscalationCount != null &&
                    this.TotalEscalationCount.Equals(input.TotalEscalationCount))
                ) && 
                (
                    this.TotalIncidentCount == input.TotalIncidentCount ||
                    (this.TotalIncidentCount != null &&
                    this.TotalIncidentCount.Equals(input.TotalIncidentCount))
                ) && 
                (
                    this.TotalOffHourInterruptions == input.TotalOffHourInterruptions ||
                    (this.TotalOffHourInterruptions != null &&
                    this.TotalOffHourInterruptions.Equals(input.TotalOffHourInterruptions))
                ) && 
                (
                    this.TotalSleepHourInterruptions == input.TotalSleepHourInterruptions ||
                    (this.TotalSleepHourInterruptions != null &&
                    this.TotalSleepHourInterruptions.Equals(input.TotalSleepHourInterruptions))
                ) && 
                (
                    this.TotalSnoozedSeconds == input.TotalSnoozedSeconds ||
                    (this.TotalSnoozedSeconds != null &&
                    this.TotalSnoozedSeconds.Equals(input.TotalSnoozedSeconds))
                ) && 
                (
                    this.UpTimePct == input.UpTimePct ||
                    (this.UpTimePct != null &&
                    this.UpTimePct.Equals(input.UpTimePct))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.MeanAssignmentCount != null)
                    hashCode = hashCode * 59 + this.MeanAssignmentCount.GetHashCode();
                if (this.MeanEngagedSeconds != null)
                    hashCode = hashCode * 59 + this.MeanEngagedSeconds.GetHashCode();
                if (this.MeanEngagedUserCount != null)
                    hashCode = hashCode * 59 + this.MeanEngagedUserCount.GetHashCode();
                if (this.MeanSecondsToEngage != null)
                    hashCode = hashCode * 59 + this.MeanSecondsToEngage.GetHashCode();
                if (this.MeanSecondsToFirstAck != null)
                    hashCode = hashCode * 59 + this.MeanSecondsToFirstAck.GetHashCode();
                if (this.MeanSecondsToMobilize != null)
                    hashCode = hashCode * 59 + this.MeanSecondsToMobilize.GetHashCode();
                if (this.MeanSecondsToResolve != null)
                    hashCode = hashCode * 59 + this.MeanSecondsToResolve.GetHashCode();
                if (this.ServiceId != null)
                    hashCode = hashCode * 59 + this.ServiceId.GetHashCode();
                if (this.ServiceName != null)
                    hashCode = hashCode * 59 + this.ServiceName.GetHashCode();
                if (this.TeamId != null)
                    hashCode = hashCode * 59 + this.TeamId.GetHashCode();
                if (this.TeamName != null)
                    hashCode = hashCode * 59 + this.TeamName.GetHashCode();
                if (this.TotalBusinessHourInterruptions != null)
                    hashCode = hashCode * 59 + this.TotalBusinessHourInterruptions.GetHashCode();
                if (this.TotalEngagedSeconds != null)
                    hashCode = hashCode * 59 + this.TotalEngagedSeconds.GetHashCode();
                if (this.TotalEscalationCount != null)
                    hashCode = hashCode * 59 + this.TotalEscalationCount.GetHashCode();
                if (this.TotalIncidentCount != null)
                    hashCode = hashCode * 59 + this.TotalIncidentCount.GetHashCode();
                if (this.TotalOffHourInterruptions != null)
                    hashCode = hashCode * 59 + this.TotalOffHourInterruptions.GetHashCode();
                if (this.TotalSleepHourInterruptions != null)
                    hashCode = hashCode * 59 + this.TotalSleepHourInterruptions.GetHashCode();
                if (this.TotalSnoozedSeconds != null)
                    hashCode = hashCode * 59 + this.TotalSnoozedSeconds.GetHashCode();
                if (this.UpTimePct != null)
                    hashCode = hashCode * 59 + this.UpTimePct.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
