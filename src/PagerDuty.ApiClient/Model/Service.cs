/* 
 * PagerDuty API
 *
 * This document describes the PagerDuty REST APIs.  For guides and examples please visit our [Documentation.](https://developer.pagerduty.com/docs/get-started/getting-started/)  Our REST APIs are defined in OpenAPI v3.x. You can view the schema at [github.com/PagerDuty/api-schema](https://github.com/PagerDuty/api-schema).  Note that properties in some schemas have fields not shown by default such as `readOnly`, `format`, and `default`. Hover your cursor over the right column that looks like `optional+1` to see the full list of fields. 
 *
 * OpenAPI spec version: 2.0.0
 * Contact: support@pagerduty.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = PagerDuty.ApiClient.Client.SwaggerDateConverter;

namespace PagerDuty.ApiClient.Model
{
    /// <summary>
    /// Service
    /// </summary>
    [DataContract]
        public partial class Service :  IEquatable<Service>, IValidatableObject
    {
        /// <summary>
        /// The type of object being created.
        /// </summary>
        /// <value>The type of object being created.</value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum TypeEnum
        {
            /// <summary>
            /// Enum Service for value: service
            /// </summary>
            [EnumMember(Value = "service")]
            Service = 1        }
        /// <summary>
        /// The type of object being created.
        /// </summary>
        /// <value>The type of object being created.</value>
        [DataMember(Name="type", EmitDefaultValue=false)]
        public TypeEnum Type { get; set; }
        /// <summary>
        /// The current state of the Service. Valid statuses are:   - &#x60;active&#x60;: The service is enabled and has no open incidents. This is the only status a service can be created with. - &#x60;warning&#x60;: The service is enabled and has one or more acknowledged incidents. - &#x60;critical&#x60;: The service is enabled and has one or more triggered incidents. - &#x60;maintenance&#x60;: The service is under maintenance, no new incidents will be triggered during maintenance mode. - &#x60;disabled&#x60;: The service is disabled and will not have any new triggered incidents. 
        /// </summary>
        /// <value>The current state of the Service. Valid statuses are:   - &#x60;active&#x60;: The service is enabled and has no open incidents. This is the only status a service can be created with. - &#x60;warning&#x60;: The service is enabled and has one or more acknowledged incidents. - &#x60;critical&#x60;: The service is enabled and has one or more triggered incidents. - &#x60;maintenance&#x60;: The service is under maintenance, no new incidents will be triggered during maintenance mode. - &#x60;disabled&#x60;: The service is disabled and will not have any new triggered incidents. </value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum StatusEnum
        {
            /// <summary>
            /// Enum Active for value: active
            /// </summary>
            [EnumMember(Value = "active")]
            Active = 1,
            /// <summary>
            /// Enum Warning for value: warning
            /// </summary>
            [EnumMember(Value = "warning")]
            Warning = 2,
            /// <summary>
            /// Enum Critical for value: critical
            /// </summary>
            [EnumMember(Value = "critical")]
            Critical = 3,
            /// <summary>
            /// Enum Maintenance for value: maintenance
            /// </summary>
            [EnumMember(Value = "maintenance")]
            Maintenance = 4,
            /// <summary>
            /// Enum Disabled for value: disabled
            /// </summary>
            [EnumMember(Value = "disabled")]
            Disabled = 5        }
        /// <summary>
        /// The current state of the Service. Valid statuses are:   - &#x60;active&#x60;: The service is enabled and has no open incidents. This is the only status a service can be created with. - &#x60;warning&#x60;: The service is enabled and has one or more acknowledged incidents. - &#x60;critical&#x60;: The service is enabled and has one or more triggered incidents. - &#x60;maintenance&#x60;: The service is under maintenance, no new incidents will be triggered during maintenance mode. - &#x60;disabled&#x60;: The service is disabled and will not have any new triggered incidents. 
        /// </summary>
        /// <value>The current state of the Service. Valid statuses are:   - &#x60;active&#x60;: The service is enabled and has no open incidents. This is the only status a service can be created with. - &#x60;warning&#x60;: The service is enabled and has one or more acknowledged incidents. - &#x60;critical&#x60;: The service is enabled and has one or more triggered incidents. - &#x60;maintenance&#x60;: The service is under maintenance, no new incidents will be triggered during maintenance mode. - &#x60;disabled&#x60;: The service is disabled and will not have any new triggered incidents. </value>
        [DataMember(Name="status", EmitDefaultValue=false)]
        public StatusEnum? Status { get; set; }
        /// <summary>
        /// Whether a service creates only incidents, or both alerts and incidents. A service must create alerts in order to enable incident merging. * \&quot;create_incidents\&quot; - The service will create one incident and zero alerts for each incoming event. * \&quot;create_alerts_and_incidents\&quot; - The service will create one incident and one associated alert for each incoming event. 
        /// </summary>
        /// <value>Whether a service creates only incidents, or both alerts and incidents. A service must create alerts in order to enable incident merging. * \&quot;create_incidents\&quot; - The service will create one incident and zero alerts for each incoming event. * \&quot;create_alerts_and_incidents\&quot; - The service will create one incident and one associated alert for each incoming event. </value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum AlertCreationEnum
        {
            /// <summary>
            /// Enum Incidents for value: create_incidents
            /// </summary>
            [EnumMember(Value = "create_incidents")]
            Incidents = 1,
            /// <summary>
            /// Enum Alertsandincidents for value: create_alerts_and_incidents
            /// </summary>
            [EnumMember(Value = "create_alerts_and_incidents")]
            Alertsandincidents = 2        }
        /// <summary>
        /// Whether a service creates only incidents, or both alerts and incidents. A service must create alerts in order to enable incident merging. * \&quot;create_incidents\&quot; - The service will create one incident and zero alerts for each incoming event. * \&quot;create_alerts_and_incidents\&quot; - The service will create one incident and one associated alert for each incoming event. 
        /// </summary>
        /// <value>Whether a service creates only incidents, or both alerts and incidents. A service must create alerts in order to enable incident merging. * \&quot;create_incidents\&quot; - The service will create one incident and zero alerts for each incoming event. * \&quot;create_alerts_and_incidents\&quot; - The service will create one incident and one associated alert for each incoming event. </value>
        [DataMember(Name="alert_creation", EmitDefaultValue=false)]
        public AlertCreationEnum? AlertCreation { get; set; }
        /// <summary>
        /// Defines how alerts on this service will be automatically grouped into incidents. Note that the alert grouping features are available only on certain plans. There are three available options: * null - No alert grouping on the service. Each alert will create a separate incident; * \&quot;time\&quot; - All alerts within a specified duration will be grouped into the same incident. This duration is set in the &#x60;alert_grouping_timeout&#x60; setting (described below). Available on Standard, Enterprise, and Event Intelligence plans; * \&quot;intelligent\&quot; - Alerts will be intelligently grouped based on a machine learning model that looks at the alert summary, timing, and the history of grouped alerts. Available on Enterprise and Event Intelligence plans 
        /// </summary>
        /// <value>Defines how alerts on this service will be automatically grouped into incidents. Note that the alert grouping features are available only on certain plans. There are three available options: * null - No alert grouping on the service. Each alert will create a separate incident; * \&quot;time\&quot; - All alerts within a specified duration will be grouped into the same incident. This duration is set in the &#x60;alert_grouping_timeout&#x60; setting (described below). Available on Standard, Enterprise, and Event Intelligence plans; * \&quot;intelligent\&quot; - Alerts will be intelligently grouped based on a machine learning model that looks at the alert summary, timing, and the history of grouped alerts. Available on Enterprise and Event Intelligence plans </value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum AlertGroupingEnum
        {
            /// <summary>
            /// Enum Time for value: time
            /// </summary>
            [EnumMember(Value = "time")]
            Time = 1,
            /// <summary>
            /// Enum Intelligent for value: intelligent
            /// </summary>
            [EnumMember(Value = "intelligent")]
            Intelligent = 2        }
        /// <summary>
        /// Defines how alerts on this service will be automatically grouped into incidents. Note that the alert grouping features are available only on certain plans. There are three available options: * null - No alert grouping on the service. Each alert will create a separate incident; * \&quot;time\&quot; - All alerts within a specified duration will be grouped into the same incident. This duration is set in the &#x60;alert_grouping_timeout&#x60; setting (described below). Available on Standard, Enterprise, and Event Intelligence plans; * \&quot;intelligent\&quot; - Alerts will be intelligently grouped based on a machine learning model that looks at the alert summary, timing, and the history of grouped alerts. Available on Enterprise and Event Intelligence plans 
        /// </summary>
        /// <value>Defines how alerts on this service will be automatically grouped into incidents. Note that the alert grouping features are available only on certain plans. There are three available options: * null - No alert grouping on the service. Each alert will create a separate incident; * \&quot;time\&quot; - All alerts within a specified duration will be grouped into the same incident. This duration is set in the &#x60;alert_grouping_timeout&#x60; setting (described below). Available on Standard, Enterprise, and Event Intelligence plans; * \&quot;intelligent\&quot; - Alerts will be intelligently grouped based on a machine learning model that looks at the alert summary, timing, and the history of grouped alerts. Available on Enterprise and Event Intelligence plans </value>
        [DataMember(Name="alert_grouping", EmitDefaultValue=false)]
        public AlertGroupingEnum? AlertGrouping { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="Service" /> class.
        /// </summary>
        /// <param name="type">The type of object being created. (required) (default to TypeEnum.Service).</param>
        /// <param name="name">The name of the service..</param>
        /// <param name="description">The user-provided description of the service..</param>
        /// <param name="autoResolveTimeout">Time in seconds that an incident is automatically resolved if left open for that long. Value is &#x60;null&#x60; if the feature is disabled. Value must not be negative. Setting this field to &#x60;0&#x60;, &#x60;null&#x60; (or unset in POST request) will disable the feature. (default to 14400).</param>
        /// <param name="acknowledgementTimeout">Time in seconds that an incident changes to the Triggered State after being Acknowledged. Value is &#x60;null&#x60; if the feature is disabled. Value must not be negative. Setting this field to &#x60;0&#x60;, &#x60;null&#x60; (or unset in POST request) will disable the feature. (default to 1800).</param>
        /// <param name="status">The current state of the Service. Valid statuses are:   - &#x60;active&#x60;: The service is enabled and has no open incidents. This is the only status a service can be created with. - &#x60;warning&#x60;: The service is enabled and has one or more acknowledged incidents. - &#x60;critical&#x60;: The service is enabled and has one or more triggered incidents. - &#x60;maintenance&#x60;: The service is under maintenance, no new incidents will be triggered during maintenance mode. - &#x60;disabled&#x60;: The service is disabled and will not have any new triggered incidents.  (default to StatusEnum.Active).</param>
        /// <param name="escalationPolicy">escalationPolicy (required).</param>
        /// <param name="responsePlay">responsePlay.</param>
        /// <param name="incidentUrgencyRule">incidentUrgencyRule.</param>
        /// <param name="supportHours">supportHours.</param>
        /// <param name="scheduledActions">An array containing scheduled actions for the service..</param>
        /// <param name="alertCreation">Whether a service creates only incidents, or both alerts and incidents. A service must create alerts in order to enable incident merging. * \&quot;create_incidents\&quot; - The service will create one incident and zero alerts for each incoming event. * \&quot;create_alerts_and_incidents\&quot; - The service will create one incident and one associated alert for each incoming event. .</param>
        /// <param name="alertGroupingParameters">alertGroupingParameters.</param>
        /// <param name="alertGrouping">Defines how alerts on this service will be automatically grouped into incidents. Note that the alert grouping features are available only on certain plans. There are three available options: * null - No alert grouping on the service. Each alert will create a separate incident; * \&quot;time\&quot; - All alerts within a specified duration will be grouped into the same incident. This duration is set in the &#x60;alert_grouping_timeout&#x60; setting (described below). Available on Standard, Enterprise, and Event Intelligence plans; * \&quot;intelligent\&quot; - Alerts will be intelligently grouped based on a machine learning model that looks at the alert summary, timing, and the history of grouped alerts. Available on Enterprise and Event Intelligence plans .</param>
        /// <param name="alertGroupingTimeout">The duration in minutes within which to automatically group incoming alerts. This setting applies only when &#x60;alert_grouping&#x60; is set to &#x60;time&#x60;. To continue grouping alerts until the Incident is resolved, set this value to &#x60;0&#x60;. .</param>
        /// <param name="autoPauseNotificationsParameters">autoPauseNotificationsParameters.</param>
        public Service(TypeEnum type = TypeEnum.Service, string name = default(string), string description = default(string), int? autoResolveTimeout = 14400, int? acknowledgementTimeout = 1800, StatusEnum? status = StatusEnum.Active, EscalationPolicyReference escalationPolicy = default(EscalationPolicyReference), Object responsePlay = default(Object), IncidentUrgencyRule incidentUrgencyRule = default(IncidentUrgencyRule), SupportHours supportHours = default(SupportHours), List<ScheduledAction> scheduledActions = default(List<ScheduledAction>), AlertCreationEnum? alertCreation = default(AlertCreationEnum?), AlertGroupingParameters alertGroupingParameters = default(AlertGroupingParameters), AlertGroupingEnum? alertGrouping = default(AlertGroupingEnum?), int? alertGroupingTimeout = default(int?), AutoPauseNotificationsParameters autoPauseNotificationsParameters = default(AutoPauseNotificationsParameters))
        {
            // to ensure "type" is required (not null)
            if (type == null)
            {
                throw new InvalidDataException("type is a required property for Service and cannot be null");
            }
            else
            {
                this.Type = type;
            }
            // to ensure "escalationPolicy" is required (not null)
            if (escalationPolicy == null)
            {
                throw new InvalidDataException("escalationPolicy is a required property for Service and cannot be null");
            }
            else
            {
                this.EscalationPolicy = escalationPolicy;
            }
            this.Name = name;
            this.Description = description;
            // use default value if no "autoResolveTimeout" provided
            if (autoResolveTimeout == null)
            {
                this.AutoResolveTimeout = 14400;
            }
            else
            {
                this.AutoResolveTimeout = autoResolveTimeout;
            }
            // use default value if no "acknowledgementTimeout" provided
            if (acknowledgementTimeout == null)
            {
                this.AcknowledgementTimeout = 1800;
            }
            else
            {
                this.AcknowledgementTimeout = acknowledgementTimeout;
            }
            // use default value if no "status" provided
            if (status == null)
            {
                this.Status = StatusEnum.Active;
            }
            else
            {
                this.Status = status;
            }
            this.ResponsePlay = responsePlay;
            this.IncidentUrgencyRule = incidentUrgencyRule;
            this.SupportHours = supportHours;
            this.ScheduledActions = scheduledActions;
            this.AlertCreation = alertCreation;
            this.AlertGroupingParameters = alertGroupingParameters;
            this.AlertGrouping = alertGrouping;
            this.AlertGroupingTimeout = alertGroupingTimeout;
            this.AutoPauseNotificationsParameters = autoPauseNotificationsParameters;
        }
        

        /// <summary>
        /// The name of the service.
        /// </summary>
        /// <value>The name of the service.</value>
        [DataMember(Name="name", EmitDefaultValue=false)]
        public string Name { get; set; }

        /// <summary>
        /// The user-provided description of the service.
        /// </summary>
        /// <value>The user-provided description of the service.</value>
        [DataMember(Name="description", EmitDefaultValue=false)]
        public string Description { get; set; }

        /// <summary>
        /// Time in seconds that an incident is automatically resolved if left open for that long. Value is &#x60;null&#x60; if the feature is disabled. Value must not be negative. Setting this field to &#x60;0&#x60;, &#x60;null&#x60; (or unset in POST request) will disable the feature.
        /// </summary>
        /// <value>Time in seconds that an incident is automatically resolved if left open for that long. Value is &#x60;null&#x60; if the feature is disabled. Value must not be negative. Setting this field to &#x60;0&#x60;, &#x60;null&#x60; (or unset in POST request) will disable the feature.</value>
        [DataMember(Name="auto_resolve_timeout", EmitDefaultValue=false)]
        public int? AutoResolveTimeout { get; set; }

        /// <summary>
        /// Time in seconds that an incident changes to the Triggered State after being Acknowledged. Value is &#x60;null&#x60; if the feature is disabled. Value must not be negative. Setting this field to &#x60;0&#x60;, &#x60;null&#x60; (or unset in POST request) will disable the feature.
        /// </summary>
        /// <value>Time in seconds that an incident changes to the Triggered State after being Acknowledged. Value is &#x60;null&#x60; if the feature is disabled. Value must not be negative. Setting this field to &#x60;0&#x60;, &#x60;null&#x60; (or unset in POST request) will disable the feature.</value>
        [DataMember(Name="acknowledgement_timeout", EmitDefaultValue=false)]
        public int? AcknowledgementTimeout { get; set; }

        /// <summary>
        /// The date/time when this service was created
        /// </summary>
        /// <value>The date/time when this service was created</value>
        [DataMember(Name="created_at", EmitDefaultValue=false)]
        public DateTime? CreatedAt { get; private set; }


        /// <summary>
        /// The date/time when the most recent incident was created for this service.
        /// </summary>
        /// <value>The date/time when the most recent incident was created for this service.</value>
        [DataMember(Name="last_incident_timestamp", EmitDefaultValue=false)]
        public DateTime? LastIncidentTimestamp { get; private set; }

        /// <summary>
        /// Gets or Sets EscalationPolicy
        /// </summary>
        [DataMember(Name="escalation_policy", EmitDefaultValue=false)]
        public EscalationPolicyReference EscalationPolicy { get; set; }

        /// <summary>
        /// Gets or Sets ResponsePlay
        /// </summary>
        [DataMember(Name="response_play", EmitDefaultValue=false)]
        public Object ResponsePlay { get; set; }

        /// <summary>
        /// The set of teams associated with this service.
        /// </summary>
        /// <value>The set of teams associated with this service.</value>
        [DataMember(Name="teams", EmitDefaultValue=false)]
        public List<TeamReference> Teams { get; private set; }

        /// <summary>
        /// An array containing Integration objects that belong to this service. If &#x60;integrations&#x60; is passed as an argument, these are full objects - otherwise, these are references.
        /// </summary>
        /// <value>An array containing Integration objects that belong to this service. If &#x60;integrations&#x60; is passed as an argument, these are full objects - otherwise, these are references.</value>
        [DataMember(Name="integrations", EmitDefaultValue=false)]
        public List<IntegrationReference> Integrations { get; private set; }

        /// <summary>
        /// Gets or Sets IncidentUrgencyRule
        /// </summary>
        [DataMember(Name="incident_urgency_rule", EmitDefaultValue=false)]
        public IncidentUrgencyRule IncidentUrgencyRule { get; set; }

        /// <summary>
        /// Gets or Sets SupportHours
        /// </summary>
        [DataMember(Name="support_hours", EmitDefaultValue=false)]
        public SupportHours SupportHours { get; set; }

        /// <summary>
        /// An array containing scheduled actions for the service.
        /// </summary>
        /// <value>An array containing scheduled actions for the service.</value>
        [DataMember(Name="scheduled_actions", EmitDefaultValue=false)]
        public List<ScheduledAction> ScheduledActions { get; set; }

        /// <summary>
        /// The array of Add-ons associated with this service.
        /// </summary>
        /// <value>The array of Add-ons associated with this service.</value>
        [DataMember(Name="addons", EmitDefaultValue=false)]
        public List<AddonReference> Addons { get; private set; }


        /// <summary>
        /// Gets or Sets AlertGroupingParameters
        /// </summary>
        [DataMember(Name="alert_grouping_parameters", EmitDefaultValue=false)]
        public AlertGroupingParameters AlertGroupingParameters { get; set; }


        /// <summary>
        /// The duration in minutes within which to automatically group incoming alerts. This setting applies only when &#x60;alert_grouping&#x60; is set to &#x60;time&#x60;. To continue grouping alerts until the Incident is resolved, set this value to &#x60;0&#x60;. 
        /// </summary>
        /// <value>The duration in minutes within which to automatically group incoming alerts. This setting applies only when &#x60;alert_grouping&#x60; is set to &#x60;time&#x60;. To continue grouping alerts until the Incident is resolved, set this value to &#x60;0&#x60;. </value>
        [DataMember(Name="alert_grouping_timeout", EmitDefaultValue=false)]
        public int? AlertGroupingTimeout { get; set; }

        /// <summary>
        /// Gets or Sets AutoPauseNotificationsParameters
        /// </summary>
        [DataMember(Name="auto_pause_notifications_parameters", EmitDefaultValue=false)]
        public AutoPauseNotificationsParameters AutoPauseNotificationsParameters { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class Service {\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  AutoResolveTimeout: ").Append(AutoResolveTimeout).Append("\n");
            sb.Append("  AcknowledgementTimeout: ").Append(AcknowledgementTimeout).Append("\n");
            sb.Append("  CreatedAt: ").Append(CreatedAt).Append("\n");
            sb.Append("  Status: ").Append(Status).Append("\n");
            sb.Append("  LastIncidentTimestamp: ").Append(LastIncidentTimestamp).Append("\n");
            sb.Append("  EscalationPolicy: ").Append(EscalationPolicy).Append("\n");
            sb.Append("  ResponsePlay: ").Append(ResponsePlay).Append("\n");
            sb.Append("  Teams: ").Append(Teams).Append("\n");
            sb.Append("  Integrations: ").Append(Integrations).Append("\n");
            sb.Append("  IncidentUrgencyRule: ").Append(IncidentUrgencyRule).Append("\n");
            sb.Append("  SupportHours: ").Append(SupportHours).Append("\n");
            sb.Append("  ScheduledActions: ").Append(ScheduledActions).Append("\n");
            sb.Append("  Addons: ").Append(Addons).Append("\n");
            sb.Append("  AlertCreation: ").Append(AlertCreation).Append("\n");
            sb.Append("  AlertGroupingParameters: ").Append(AlertGroupingParameters).Append("\n");
            sb.Append("  AlertGrouping: ").Append(AlertGrouping).Append("\n");
            sb.Append("  AlertGroupingTimeout: ").Append(AlertGroupingTimeout).Append("\n");
            sb.Append("  AutoPauseNotificationsParameters: ").Append(AutoPauseNotificationsParameters).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Service);
        }

        /// <summary>
        /// Returns true if Service instances are equal
        /// </summary>
        /// <param name="input">Instance of Service to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Service input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Type == input.Type ||
                    (this.Type != null &&
                    this.Type.Equals(input.Type))
                ) && 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.Description == input.Description ||
                    (this.Description != null &&
                    this.Description.Equals(input.Description))
                ) && 
                (
                    this.AutoResolveTimeout == input.AutoResolveTimeout ||
                    (this.AutoResolveTimeout != null &&
                    this.AutoResolveTimeout.Equals(input.AutoResolveTimeout))
                ) && 
                (
                    this.AcknowledgementTimeout == input.AcknowledgementTimeout ||
                    (this.AcknowledgementTimeout != null &&
                    this.AcknowledgementTimeout.Equals(input.AcknowledgementTimeout))
                ) && 
                (
                    this.CreatedAt == input.CreatedAt ||
                    (this.CreatedAt != null &&
                    this.CreatedAt.Equals(input.CreatedAt))
                ) && 
                (
                    this.Status == input.Status ||
                    (this.Status != null &&
                    this.Status.Equals(input.Status))
                ) && 
                (
                    this.LastIncidentTimestamp == input.LastIncidentTimestamp ||
                    (this.LastIncidentTimestamp != null &&
                    this.LastIncidentTimestamp.Equals(input.LastIncidentTimestamp))
                ) && 
                (
                    this.EscalationPolicy == input.EscalationPolicy ||
                    (this.EscalationPolicy != null &&
                    this.EscalationPolicy.Equals(input.EscalationPolicy))
                ) && 
                (
                    this.ResponsePlay == input.ResponsePlay ||
                    (this.ResponsePlay != null &&
                    this.ResponsePlay.Equals(input.ResponsePlay))
                ) && 
                (
                    this.Teams == input.Teams ||
                    this.Teams != null &&
                    input.Teams != null &&
                    this.Teams.SequenceEqual(input.Teams)
                ) && 
                (
                    this.Integrations == input.Integrations ||
                    this.Integrations != null &&
                    input.Integrations != null &&
                    this.Integrations.SequenceEqual(input.Integrations)
                ) && 
                (
                    this.IncidentUrgencyRule == input.IncidentUrgencyRule ||
                    (this.IncidentUrgencyRule != null &&
                    this.IncidentUrgencyRule.Equals(input.IncidentUrgencyRule))
                ) && 
                (
                    this.SupportHours == input.SupportHours ||
                    (this.SupportHours != null &&
                    this.SupportHours.Equals(input.SupportHours))
                ) && 
                (
                    this.ScheduledActions == input.ScheduledActions ||
                    this.ScheduledActions != null &&
                    input.ScheduledActions != null &&
                    this.ScheduledActions.SequenceEqual(input.ScheduledActions)
                ) && 
                (
                    this.Addons == input.Addons ||
                    this.Addons != null &&
                    input.Addons != null &&
                    this.Addons.SequenceEqual(input.Addons)
                ) && 
                (
                    this.AlertCreation == input.AlertCreation ||
                    (this.AlertCreation != null &&
                    this.AlertCreation.Equals(input.AlertCreation))
                ) && 
                (
                    this.AlertGroupingParameters == input.AlertGroupingParameters ||
                    (this.AlertGroupingParameters != null &&
                    this.AlertGroupingParameters.Equals(input.AlertGroupingParameters))
                ) && 
                (
                    this.AlertGrouping == input.AlertGrouping ||
                    (this.AlertGrouping != null &&
                    this.AlertGrouping.Equals(input.AlertGrouping))
                ) && 
                (
                    this.AlertGroupingTimeout == input.AlertGroupingTimeout ||
                    (this.AlertGroupingTimeout != null &&
                    this.AlertGroupingTimeout.Equals(input.AlertGroupingTimeout))
                ) && 
                (
                    this.AutoPauseNotificationsParameters == input.AutoPauseNotificationsParameters ||
                    (this.AutoPauseNotificationsParameters != null &&
                    this.AutoPauseNotificationsParameters.Equals(input.AutoPauseNotificationsParameters))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Type != null)
                    hashCode = hashCode * 59 + this.Type.GetHashCode();
                if (this.Name != null)
                    hashCode = hashCode * 59 + this.Name.GetHashCode();
                if (this.Description != null)
                    hashCode = hashCode * 59 + this.Description.GetHashCode();
                if (this.AutoResolveTimeout != null)
                    hashCode = hashCode * 59 + this.AutoResolveTimeout.GetHashCode();
                if (this.AcknowledgementTimeout != null)
                    hashCode = hashCode * 59 + this.AcknowledgementTimeout.GetHashCode();
                if (this.CreatedAt != null)
                    hashCode = hashCode * 59 + this.CreatedAt.GetHashCode();
                if (this.Status != null)
                    hashCode = hashCode * 59 + this.Status.GetHashCode();
                if (this.LastIncidentTimestamp != null)
                    hashCode = hashCode * 59 + this.LastIncidentTimestamp.GetHashCode();
                if (this.EscalationPolicy != null)
                    hashCode = hashCode * 59 + this.EscalationPolicy.GetHashCode();
                if (this.ResponsePlay != null)
                    hashCode = hashCode * 59 + this.ResponsePlay.GetHashCode();
                if (this.Teams != null)
                    hashCode = hashCode * 59 + this.Teams.GetHashCode();
                if (this.Integrations != null)
                    hashCode = hashCode * 59 + this.Integrations.GetHashCode();
                if (this.IncidentUrgencyRule != null)
                    hashCode = hashCode * 59 + this.IncidentUrgencyRule.GetHashCode();
                if (this.SupportHours != null)
                    hashCode = hashCode * 59 + this.SupportHours.GetHashCode();
                if (this.ScheduledActions != null)
                    hashCode = hashCode * 59 + this.ScheduledActions.GetHashCode();
                if (this.Addons != null)
                    hashCode = hashCode * 59 + this.Addons.GetHashCode();
                if (this.AlertCreation != null)
                    hashCode = hashCode * 59 + this.AlertCreation.GetHashCode();
                if (this.AlertGroupingParameters != null)
                    hashCode = hashCode * 59 + this.AlertGroupingParameters.GetHashCode();
                if (this.AlertGrouping != null)
                    hashCode = hashCode * 59 + this.AlertGrouping.GetHashCode();
                if (this.AlertGroupingTimeout != null)
                    hashCode = hashCode * 59 + this.AlertGroupingTimeout.GetHashCode();
                if (this.AutoPauseNotificationsParameters != null)
                    hashCode = hashCode * 59 + this.AutoPauseNotificationsParameters.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
