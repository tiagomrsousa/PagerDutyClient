/* 
 * PagerDuty API
 *
 * This document describes the PagerDuty REST APIs.  For guides and examples please visit our [Documentation.](https://developer.pagerduty.com/docs/get-started/getting-started/)  Our REST APIs are defined in OpenAPI v3.x. You can view the schema at [github.com/PagerDuty/api-schema](https://github.com/PagerDuty/api-schema).  Note that properties in some schemas have fields not shown by default such as `readOnly`, `format`, and `default`. Hover your cursor over the right column that looks like `optional+1` to see the full list of fields. 
 *
 * OpenAPI spec version: 2.0.0
 * Contact: support@pagerduty.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using PagerDuty.ApiClient.Client;
using PagerDuty.ApiClient.Model;

namespace PagerDuty.ApiClient.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
        public interface IEventOrchestrationsApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Delete an Orchestration
        /// </summary>
        /// <remarks>
        /// Delete a Global Event Orchestration.  Once deleted, you will no longer be able to ingest events into PagerDuty using this Orchestration&#x27;s routing key.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns></returns>
        void DeleteOrchestration (string accept, string contentType, string authorization, string id);

        /// <summary>
        /// Delete an Orchestration
        /// </summary>
        /// <remarks>
        /// Delete a Global Event Orchestration.  Once deleted, you will no longer be able to ingest events into PagerDuty using this Orchestration&#x27;s routing key.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteOrchestrationWithHttpInfo (string accept, string contentType, string authorization, string id);
        /// <summary>
        /// Get the Service Orchestration active status for a Service
        /// </summary>
        /// <remarks>
        /// Get a Service Orchestration&#x27;s active status.  A Service Orchestration allows you to set an active status based on whether an event will be evaluated against a service orchestration path (true) or service ruleset (false).  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.read&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns></returns>
        void GetOrchActiveStatus (string accept, string contentType, string authorization, string id);

        /// <summary>
        /// Get the Service Orchestration active status for a Service
        /// </summary>
        /// <remarks>
        /// Get a Service Orchestration&#x27;s active status.  A Service Orchestration allows you to set an active status based on whether an event will be evaluated against a service orchestration path (true) or service ruleset (false).  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.read&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> GetOrchActiveStatusWithHttpInfo (string accept, string contentType, string authorization, string id);
        /// <summary>
        /// Get the Router for a Global Event Orchestration
        /// </summary>
        /// <remarks>
        /// Get a Global Event Orchestration&#x27;s Routing Rules.  An Orchestration Router allows you to create a set of Event Rules. The Router evaluates Events you send to this Orchestration against each of its rules, one at a time, and routes the event to a specific Service based on the first rule that matches. If an event doesn&#x27;t match any rules, it&#x27;ll be sent to service specified in as the &#x60;catch_all&#x60; or the \&quot;Unrouted\&quot; Orchestration if no service is specified.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns></returns>
        void GetOrchPathRouter (string accept, string contentType, string authorization, string id);

        /// <summary>
        /// Get the Router for a Global Event Orchestration
        /// </summary>
        /// <remarks>
        /// Get a Global Event Orchestration&#x27;s Routing Rules.  An Orchestration Router allows you to create a set of Event Rules. The Router evaluates Events you send to this Orchestration against each of its rules, one at a time, and routes the event to a specific Service based on the first rule that matches. If an event doesn&#x27;t match any rules, it&#x27;ll be sent to service specified in as the &#x60;catch_all&#x60; or the \&quot;Unrouted\&quot; Orchestration if no service is specified.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> GetOrchPathRouterWithHttpInfo (string accept, string contentType, string authorization, string id);
        /// <summary>
        /// Get the Service Orchestration for a Service
        /// </summary>
        /// <remarks>
        /// Get a Service Orchestration.  A Service Orchestration allows you to create a set of Event Rules. The Service Orchestration evaluates Events sent to this Service against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Service Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.read&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns></returns>
        void GetOrchPathService (string accept, string contentType, string authorization, string id);

        /// <summary>
        /// Get the Service Orchestration for a Service
        /// </summary>
        /// <remarks>
        /// Get a Service Orchestration.  A Service Orchestration allows you to create a set of Event Rules. The Service Orchestration evaluates Events sent to this Service against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Service Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.read&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> GetOrchPathServiceWithHttpInfo (string accept, string contentType, string authorization, string id);
        /// <summary>
        /// Get the Unrouted Orchestration for a Global Event Orchestration
        /// </summary>
        /// <remarks>
        /// Get a Global Event Orchestration&#x27;s Rules for Unrouted events.  An Unrouted Orchestration allows you to create a set of Event Rules that will be evaluated against all events that don&#x27;t match any rules in the Orchestration&#x27;s Router.  The Unrouted Orchestration evaluates Events sent to it against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Unrouted Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns></returns>
        void GetOrchPathUnrouted (string accept, string contentType, string authorization, string id);

        /// <summary>
        /// Get the Unrouted Orchestration for a Global Event Orchestration
        /// </summary>
        /// <remarks>
        /// Get a Global Event Orchestration&#x27;s Rules for Unrouted events.  An Unrouted Orchestration allows you to create a set of Event Rules that will be evaluated against all events that don&#x27;t match any rules in the Orchestration&#x27;s Router.  The Unrouted Orchestration evaluates Events sent to it against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Unrouted Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> GetOrchPathUnroutedWithHttpInfo (string accept, string contentType, string authorization, string id);
        /// <summary>
        /// Get an Orchestration
        /// </summary>
        /// <remarks>
        /// Get a Global Event Orchestration.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>Object</returns>
        Object GetOrchestration (string accept, string contentType, string authorization, string id);

        /// <summary>
        /// Get an Orchestration
        /// </summary>
        /// <remarks>
        /// Get a Global Event Orchestration.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>ApiResponse of Object</returns>
        ApiResponse<Object> GetOrchestrationWithHttpInfo (string accept, string contentType, string authorization, string id);
        /// <summary>
        /// List Event Orchestrations
        /// </summary>
        /// <remarks>
        /// List all Global Event Orchestrations on an Account.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="limit">The number of results per page. (optional)</param>
        /// <param name="offset">Offset to start pagination search results. (optional)</param>
        /// <param name="sortBy">Used to specify the field you wish to sort the results on. (optional, default to name:asc)</param>
        /// <returns>Object</returns>
        Object ListEventOrchestrations (string accept, string contentType, string authorization, int? limit = null, int? offset = null, string sortBy = null);

        /// <summary>
        /// List Event Orchestrations
        /// </summary>
        /// <remarks>
        /// List all Global Event Orchestrations on an Account.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="limit">The number of results per page. (optional)</param>
        /// <param name="offset">Offset to start pagination search results. (optional)</param>
        /// <param name="sortBy">Used to specify the field you wish to sort the results on. (optional, default to name:asc)</param>
        /// <returns>ApiResponse of Object</returns>
        ApiResponse<Object> ListEventOrchestrationsWithHttpInfo (string accept, string contentType, string authorization, int? limit = null, int? offset = null, string sortBy = null);
        /// <summary>
        /// Create an Orchestration
        /// </summary>
        /// <remarks>
        /// Create a Global Event Orchestration.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Object</returns>
        Object PostOrchestration (string accept, string contentType, string authorization, Object body = null);

        /// <summary>
        /// Create an Orchestration
        /// </summary>
        /// <remarks>
        /// Create a Global Event Orchestration.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of Object</returns>
        ApiResponse<Object> PostOrchestrationWithHttpInfo (string accept, string contentType, string authorization, Object body = null);
        /// <summary>
        /// Update the Service Orchestration active status for a Service
        /// </summary>
        /// <remarks>
        /// Update a Service Orchestration&#x27;s active status.  A Service Orchestration allows you to set an active status based on whether an event will be evaluated against a service orchestration path (true) or service ruleset (false).  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.write&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns></returns>
        void UpdateOrchActiveStatus (string accept, string contentType, string authorization, string id);

        /// <summary>
        /// Update the Service Orchestration active status for a Service
        /// </summary>
        /// <remarks>
        /// Update a Service Orchestration&#x27;s active status.  A Service Orchestration allows you to set an active status based on whether an event will be evaluated against a service orchestration path (true) or service ruleset (false).  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.write&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateOrchActiveStatusWithHttpInfo (string accept, string contentType, string authorization, string id);
        /// <summary>
        /// Update the Router for a Global Event Orchestration
        /// </summary>
        /// <remarks>
        /// Update an Orchestration&#x27;s Routing Rules.  An Orchestration Router allows you to create a set of Event Rules. The Router evaluates Events you send to this Orchestration against each of its rules, one at a time, and routes the event to a specific Service based on the first rule that matches. If an event doesn&#x27;t match any rules, it&#x27;ll be sent to service specified in as the &#x60;catch_all&#x60; or the \&quot;Unrouted\&quot; Orchestration if no service is specified.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body">Updates to Orchestration Router details. Omitted rules and rule details are deleted. (optional)</param>
        /// <returns></returns>
        void UpdateOrchPathRouter (string accept, string contentType, string authorization, string id, OrchestrationRouter body = null);

        /// <summary>
        /// Update the Router for a Global Event Orchestration
        /// </summary>
        /// <remarks>
        /// Update an Orchestration&#x27;s Routing Rules.  An Orchestration Router allows you to create a set of Event Rules. The Router evaluates Events you send to this Orchestration against each of its rules, one at a time, and routes the event to a specific Service based on the first rule that matches. If an event doesn&#x27;t match any rules, it&#x27;ll be sent to service specified in as the &#x60;catch_all&#x60; or the \&quot;Unrouted\&quot; Orchestration if no service is specified.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body">Updates to Orchestration Router details. Omitted rules and rule details are deleted. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateOrchPathRouterWithHttpInfo (string accept, string contentType, string authorization, string id, OrchestrationRouter body = null);
        /// <summary>
        /// Update the Service Orchestration for a Service
        /// </summary>
        /// <remarks>
        /// Update a Service Orchestration.  A Service Orchestration allows you to create a set of Event Rules. The Service Orchestration evaluates Events sent to this Service against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Service Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.write&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body">Update Service Orchestration rules. Omitted rules and rule details are deleted. (optional)</param>
        /// <returns></returns>
        void UpdateOrchPathService (string accept, string contentType, string authorization, string id, ServiceOrchestration body = null);

        /// <summary>
        /// Update the Service Orchestration for a Service
        /// </summary>
        /// <remarks>
        /// Update a Service Orchestration.  A Service Orchestration allows you to create a set of Event Rules. The Service Orchestration evaluates Events sent to this Service against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Service Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.write&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body">Update Service Orchestration rules. Omitted rules and rule details are deleted. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateOrchPathServiceWithHttpInfo (string accept, string contentType, string authorization, string id, ServiceOrchestration body = null);
        /// <summary>
        /// Update the Unrouted Orchestration for a Global Event Orchestration
        /// </summary>
        /// <remarks>
        /// Update a Global Event Orchestration&#x27;s Rules for Unrouted events.  An Unrouted Orchestration allows you to create a set of Event Rules that will be evaluated against all events that don&#x27;t match any rules in the Orchestration&#x27;s Router.  The Unrouted Orchestration evaluates Events sent to it against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Unrouted Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body">Updates to Unrouted Orchestration rules. Omitted rules and rule details are deleted. (optional)</param>
        /// <returns></returns>
        void UpdateOrchPathUnrouted (string accept, string contentType, string authorization, string id, OrchestrationUnrouted body = null);

        /// <summary>
        /// Update the Unrouted Orchestration for a Global Event Orchestration
        /// </summary>
        /// <remarks>
        /// Update a Global Event Orchestration&#x27;s Rules for Unrouted events.  An Unrouted Orchestration allows you to create a set of Event Rules that will be evaluated against all events that don&#x27;t match any rules in the Orchestration&#x27;s Router.  The Unrouted Orchestration evaluates Events sent to it against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Unrouted Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body">Updates to Unrouted Orchestration rules. Omitted rules and rule details are deleted. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateOrchPathUnroutedWithHttpInfo (string accept, string contentType, string authorization, string id, OrchestrationUnrouted body = null);
        /// <summary>
        /// Update an Orchestration
        /// </summary>
        /// <remarks>
        /// Update a Global Event Orchestration.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Object</returns>
        Object UpdateOrchestration (string accept, string contentType, string authorization, string id, Object body = null);

        /// <summary>
        /// Update an Orchestration
        /// </summary>
        /// <remarks>
        /// Update a Global Event Orchestration.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of Object</returns>
        ApiResponse<Object> UpdateOrchestrationWithHttpInfo (string accept, string contentType, string authorization, string id, Object body = null);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Delete an Orchestration
        /// </summary>
        /// <remarks>
        /// Delete a Global Event Orchestration.  Once deleted, you will no longer be able to ingest events into PagerDuty using this Orchestration&#x27;s routing key.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteOrchestrationAsync (string accept, string contentType, string authorization, string id);

        /// <summary>
        /// Delete an Orchestration
        /// </summary>
        /// <remarks>
        /// Delete a Global Event Orchestration.  Once deleted, you will no longer be able to ingest events into PagerDuty using this Orchestration&#x27;s routing key.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteOrchestrationAsyncWithHttpInfo (string accept, string contentType, string authorization, string id);
        /// <summary>
        /// Get the Service Orchestration active status for a Service
        /// </summary>
        /// <remarks>
        /// Get a Service Orchestration&#x27;s active status.  A Service Orchestration allows you to set an active status based on whether an event will be evaluated against a service orchestration path (true) or service ruleset (false).  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.read&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task GetOrchActiveStatusAsync (string accept, string contentType, string authorization, string id);

        /// <summary>
        /// Get the Service Orchestration active status for a Service
        /// </summary>
        /// <remarks>
        /// Get a Service Orchestration&#x27;s active status.  A Service Orchestration allows you to set an active status based on whether an event will be evaluated against a service orchestration path (true) or service ruleset (false).  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.read&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> GetOrchActiveStatusAsyncWithHttpInfo (string accept, string contentType, string authorization, string id);
        /// <summary>
        /// Get the Router for a Global Event Orchestration
        /// </summary>
        /// <remarks>
        /// Get a Global Event Orchestration&#x27;s Routing Rules.  An Orchestration Router allows you to create a set of Event Rules. The Router evaluates Events you send to this Orchestration against each of its rules, one at a time, and routes the event to a specific Service based on the first rule that matches. If an event doesn&#x27;t match any rules, it&#x27;ll be sent to service specified in as the &#x60;catch_all&#x60; or the \&quot;Unrouted\&quot; Orchestration if no service is specified.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task GetOrchPathRouterAsync (string accept, string contentType, string authorization, string id);

        /// <summary>
        /// Get the Router for a Global Event Orchestration
        /// </summary>
        /// <remarks>
        /// Get a Global Event Orchestration&#x27;s Routing Rules.  An Orchestration Router allows you to create a set of Event Rules. The Router evaluates Events you send to this Orchestration against each of its rules, one at a time, and routes the event to a specific Service based on the first rule that matches. If an event doesn&#x27;t match any rules, it&#x27;ll be sent to service specified in as the &#x60;catch_all&#x60; or the \&quot;Unrouted\&quot; Orchestration if no service is specified.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> GetOrchPathRouterAsyncWithHttpInfo (string accept, string contentType, string authorization, string id);
        /// <summary>
        /// Get the Service Orchestration for a Service
        /// </summary>
        /// <remarks>
        /// Get a Service Orchestration.  A Service Orchestration allows you to create a set of Event Rules. The Service Orchestration evaluates Events sent to this Service against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Service Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.read&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task GetOrchPathServiceAsync (string accept, string contentType, string authorization, string id);

        /// <summary>
        /// Get the Service Orchestration for a Service
        /// </summary>
        /// <remarks>
        /// Get a Service Orchestration.  A Service Orchestration allows you to create a set of Event Rules. The Service Orchestration evaluates Events sent to this Service against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Service Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.read&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> GetOrchPathServiceAsyncWithHttpInfo (string accept, string contentType, string authorization, string id);
        /// <summary>
        /// Get the Unrouted Orchestration for a Global Event Orchestration
        /// </summary>
        /// <remarks>
        /// Get a Global Event Orchestration&#x27;s Rules for Unrouted events.  An Unrouted Orchestration allows you to create a set of Event Rules that will be evaluated against all events that don&#x27;t match any rules in the Orchestration&#x27;s Router.  The Unrouted Orchestration evaluates Events sent to it against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Unrouted Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task GetOrchPathUnroutedAsync (string accept, string contentType, string authorization, string id);

        /// <summary>
        /// Get the Unrouted Orchestration for a Global Event Orchestration
        /// </summary>
        /// <remarks>
        /// Get a Global Event Orchestration&#x27;s Rules for Unrouted events.  An Unrouted Orchestration allows you to create a set of Event Rules that will be evaluated against all events that don&#x27;t match any rules in the Orchestration&#x27;s Router.  The Unrouted Orchestration evaluates Events sent to it against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Unrouted Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> GetOrchPathUnroutedAsyncWithHttpInfo (string accept, string contentType, string authorization, string id);
        /// <summary>
        /// Get an Orchestration
        /// </summary>
        /// <remarks>
        /// Get a Global Event Orchestration.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>Task of Object</returns>
        System.Threading.Tasks.Task<Object> GetOrchestrationAsync (string accept, string contentType, string authorization, string id);

        /// <summary>
        /// Get an Orchestration
        /// </summary>
        /// <remarks>
        /// Get a Global Event Orchestration.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>Task of ApiResponse (Object)</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> GetOrchestrationAsyncWithHttpInfo (string accept, string contentType, string authorization, string id);
        /// <summary>
        /// List Event Orchestrations
        /// </summary>
        /// <remarks>
        /// List all Global Event Orchestrations on an Account.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="limit">The number of results per page. (optional)</param>
        /// <param name="offset">Offset to start pagination search results. (optional)</param>
        /// <param name="sortBy">Used to specify the field you wish to sort the results on. (optional, default to name:asc)</param>
        /// <returns>Task of Object</returns>
        System.Threading.Tasks.Task<Object> ListEventOrchestrationsAsync (string accept, string contentType, string authorization, int? limit = null, int? offset = null, string sortBy = null);

        /// <summary>
        /// List Event Orchestrations
        /// </summary>
        /// <remarks>
        /// List all Global Event Orchestrations on an Account.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="limit">The number of results per page. (optional)</param>
        /// <param name="offset">Offset to start pagination search results. (optional)</param>
        /// <param name="sortBy">Used to specify the field you wish to sort the results on. (optional, default to name:asc)</param>
        /// <returns>Task of ApiResponse (Object)</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> ListEventOrchestrationsAsyncWithHttpInfo (string accept, string contentType, string authorization, int? limit = null, int? offset = null, string sortBy = null);
        /// <summary>
        /// Create an Orchestration
        /// </summary>
        /// <remarks>
        /// Create a Global Event Orchestration.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of Object</returns>
        System.Threading.Tasks.Task<Object> PostOrchestrationAsync (string accept, string contentType, string authorization, Object body = null);

        /// <summary>
        /// Create an Orchestration
        /// </summary>
        /// <remarks>
        /// Create a Global Event Orchestration.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse (Object)</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> PostOrchestrationAsyncWithHttpInfo (string accept, string contentType, string authorization, Object body = null);
        /// <summary>
        /// Update the Service Orchestration active status for a Service
        /// </summary>
        /// <remarks>
        /// Update a Service Orchestration&#x27;s active status.  A Service Orchestration allows you to set an active status based on whether an event will be evaluated against a service orchestration path (true) or service ruleset (false).  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.write&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateOrchActiveStatusAsync (string accept, string contentType, string authorization, string id);

        /// <summary>
        /// Update the Service Orchestration active status for a Service
        /// </summary>
        /// <remarks>
        /// Update a Service Orchestration&#x27;s active status.  A Service Orchestration allows you to set an active status based on whether an event will be evaluated against a service orchestration path (true) or service ruleset (false).  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.write&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateOrchActiveStatusAsyncWithHttpInfo (string accept, string contentType, string authorization, string id);
        /// <summary>
        /// Update the Router for a Global Event Orchestration
        /// </summary>
        /// <remarks>
        /// Update an Orchestration&#x27;s Routing Rules.  An Orchestration Router allows you to create a set of Event Rules. The Router evaluates Events you send to this Orchestration against each of its rules, one at a time, and routes the event to a specific Service based on the first rule that matches. If an event doesn&#x27;t match any rules, it&#x27;ll be sent to service specified in as the &#x60;catch_all&#x60; or the \&quot;Unrouted\&quot; Orchestration if no service is specified.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body">Updates to Orchestration Router details. Omitted rules and rule details are deleted. (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateOrchPathRouterAsync (string accept, string contentType, string authorization, string id, OrchestrationRouter body = null);

        /// <summary>
        /// Update the Router for a Global Event Orchestration
        /// </summary>
        /// <remarks>
        /// Update an Orchestration&#x27;s Routing Rules.  An Orchestration Router allows you to create a set of Event Rules. The Router evaluates Events you send to this Orchestration against each of its rules, one at a time, and routes the event to a specific Service based on the first rule that matches. If an event doesn&#x27;t match any rules, it&#x27;ll be sent to service specified in as the &#x60;catch_all&#x60; or the \&quot;Unrouted\&quot; Orchestration if no service is specified.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body">Updates to Orchestration Router details. Omitted rules and rule details are deleted. (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateOrchPathRouterAsyncWithHttpInfo (string accept, string contentType, string authorization, string id, OrchestrationRouter body = null);
        /// <summary>
        /// Update the Service Orchestration for a Service
        /// </summary>
        /// <remarks>
        /// Update a Service Orchestration.  A Service Orchestration allows you to create a set of Event Rules. The Service Orchestration evaluates Events sent to this Service against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Service Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.write&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body">Update Service Orchestration rules. Omitted rules and rule details are deleted. (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateOrchPathServiceAsync (string accept, string contentType, string authorization, string id, ServiceOrchestration body = null);

        /// <summary>
        /// Update the Service Orchestration for a Service
        /// </summary>
        /// <remarks>
        /// Update a Service Orchestration.  A Service Orchestration allows you to create a set of Event Rules. The Service Orchestration evaluates Events sent to this Service against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Service Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.write&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body">Update Service Orchestration rules. Omitted rules and rule details are deleted. (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateOrchPathServiceAsyncWithHttpInfo (string accept, string contentType, string authorization, string id, ServiceOrchestration body = null);
        /// <summary>
        /// Update the Unrouted Orchestration for a Global Event Orchestration
        /// </summary>
        /// <remarks>
        /// Update a Global Event Orchestration&#x27;s Rules for Unrouted events.  An Unrouted Orchestration allows you to create a set of Event Rules that will be evaluated against all events that don&#x27;t match any rules in the Orchestration&#x27;s Router.  The Unrouted Orchestration evaluates Events sent to it against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Unrouted Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body">Updates to Unrouted Orchestration rules. Omitted rules and rule details are deleted. (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateOrchPathUnroutedAsync (string accept, string contentType, string authorization, string id, OrchestrationUnrouted body = null);

        /// <summary>
        /// Update the Unrouted Orchestration for a Global Event Orchestration
        /// </summary>
        /// <remarks>
        /// Update a Global Event Orchestration&#x27;s Rules for Unrouted events.  An Unrouted Orchestration allows you to create a set of Event Rules that will be evaluated against all events that don&#x27;t match any rules in the Orchestration&#x27;s Router.  The Unrouted Orchestration evaluates Events sent to it against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Unrouted Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body">Updates to Unrouted Orchestration rules. Omitted rules and rule details are deleted. (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateOrchPathUnroutedAsyncWithHttpInfo (string accept, string contentType, string authorization, string id, OrchestrationUnrouted body = null);
        /// <summary>
        /// Update an Orchestration
        /// </summary>
        /// <remarks>
        /// Update a Global Event Orchestration.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of Object</returns>
        System.Threading.Tasks.Task<Object> UpdateOrchestrationAsync (string accept, string contentType, string authorization, string id, Object body = null);

        /// <summary>
        /// Update an Orchestration
        /// </summary>
        /// <remarks>
        /// Update a Global Event Orchestration.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </remarks>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse (Object)</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateOrchestrationAsyncWithHttpInfo (string accept, string contentType, string authorization, string id, Object body = null);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
        public partial class EventOrchestrationsApi : IEventOrchestrationsApi
    {
        private PagerDuty.ApiClient.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="EventOrchestrationsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public EventOrchestrationsApi(String basePath)
        {
            this.Configuration = new PagerDuty.ApiClient.Client.Configuration { BasePath = basePath };

            ExceptionFactory = PagerDuty.ApiClient.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="EventOrchestrationsApi"/> class
        /// </summary>
        /// <returns></returns>
        public EventOrchestrationsApi()
        {
            this.Configuration = PagerDuty.ApiClient.Client.Configuration.Default;

            ExceptionFactory = PagerDuty.ApiClient.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="EventOrchestrationsApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public EventOrchestrationsApi(PagerDuty.ApiClient.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = PagerDuty.ApiClient.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = PagerDuty.ApiClient.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public PagerDuty.ApiClient.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public PagerDuty.ApiClient.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Delete an Orchestration Delete a Global Event Orchestration.  Once deleted, you will no longer be able to ingest events into PagerDuty using this Orchestration&#x27;s routing key.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns></returns>
        public void DeleteOrchestration (string accept, string contentType, string authorization, string id)
        {
             DeleteOrchestrationWithHttpInfo(accept, contentType, authorization, id);
        }

        /// <summary>
        /// Delete an Orchestration Delete a Global Event Orchestration.  Once deleted, you will no longer be able to ingest events into PagerDuty using this Orchestration&#x27;s routing key.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteOrchestrationWithHttpInfo (string accept, string contentType, string authorization, string id)
        {
            // verify the required parameter 'accept' is set
            if (accept == null)
                throw new ApiException(400, "Missing required parameter 'accept' when calling EventOrchestrationsApi->DeleteOrchestration");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400, "Missing required parameter 'contentType' when calling EventOrchestrationsApi->DeleteOrchestration");
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling EventOrchestrationsApi->DeleteOrchestration");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling EventOrchestrationsApi->DeleteOrchestration");

            var localVarPath = "/event_orchestrations/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.AddOrUpdate("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (accept != null) localVarHeaderParams.AddOrUpdate("Accept", this.Configuration.ApiClient.ParameterToString(accept)); // header parameter
            if (contentType != null) localVarHeaderParams.AddOrUpdate("Content-Type", this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (authorization != null) localVarHeaderParams.AddOrUpdate("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteOrchestration", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Delete an Orchestration Delete a Global Event Orchestration.  Once deleted, you will no longer be able to ingest events into PagerDuty using this Orchestration&#x27;s routing key.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteOrchestrationAsync (string accept, string contentType, string authorization, string id)
        {
             await DeleteOrchestrationAsyncWithHttpInfo(accept, contentType, authorization, id);

        }

        /// <summary>
        /// Delete an Orchestration Delete a Global Event Orchestration.  Once deleted, you will no longer be able to ingest events into PagerDuty using this Orchestration&#x27;s routing key.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteOrchestrationAsyncWithHttpInfo (string accept, string contentType, string authorization, string id)
        {
            // verify the required parameter 'accept' is set
            if (accept == null)
                throw new ApiException(400, "Missing required parameter 'accept' when calling EventOrchestrationsApi->DeleteOrchestration");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400, "Missing required parameter 'contentType' when calling EventOrchestrationsApi->DeleteOrchestration");
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling EventOrchestrationsApi->DeleteOrchestration");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling EventOrchestrationsApi->DeleteOrchestration");

            var localVarPath = "/event_orchestrations/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.AddOrUpdate("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (accept != null) localVarHeaderParams.AddOrUpdate("Accept", this.Configuration.ApiClient.ParameterToString(accept)); // header parameter
            if (contentType != null) localVarHeaderParams.AddOrUpdate("Content-Type", this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (authorization != null) localVarHeaderParams.AddOrUpdate("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteOrchestration", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Get the Service Orchestration active status for a Service Get a Service Orchestration&#x27;s active status.  A Service Orchestration allows you to set an active status based on whether an event will be evaluated against a service orchestration path (true) or service ruleset (false).  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.read&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns></returns>
        public void GetOrchActiveStatus (string accept, string contentType, string authorization, string id)
        {
             GetOrchActiveStatusWithHttpInfo(accept, contentType, authorization, id);
        }

        /// <summary>
        /// Get the Service Orchestration active status for a Service Get a Service Orchestration&#x27;s active status.  A Service Orchestration allows you to set an active status based on whether an event will be evaluated against a service orchestration path (true) or service ruleset (false).  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.read&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> GetOrchActiveStatusWithHttpInfo (string accept, string contentType, string authorization, string id)
        {
            // verify the required parameter 'accept' is set
            if (accept == null)
                throw new ApiException(400, "Missing required parameter 'accept' when calling EventOrchestrationsApi->GetOrchActiveStatus");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400, "Missing required parameter 'contentType' when calling EventOrchestrationsApi->GetOrchActiveStatus");
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling EventOrchestrationsApi->GetOrchActiveStatus");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling EventOrchestrationsApi->GetOrchActiveStatus");

            var localVarPath = "/event_orchestrations/services/{id}/active";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.AddOrUpdate("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (accept != null) localVarHeaderParams.AddOrUpdate("Accept", this.Configuration.ApiClient.ParameterToString(accept)); // header parameter
            if (contentType != null) localVarHeaderParams.AddOrUpdate("Content-Type", this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (authorization != null) localVarHeaderParams.AddOrUpdate("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetOrchActiveStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Get the Service Orchestration active status for a Service Get a Service Orchestration&#x27;s active status.  A Service Orchestration allows you to set an active status based on whether an event will be evaluated against a service orchestration path (true) or service ruleset (false).  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.read&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task GetOrchActiveStatusAsync (string accept, string contentType, string authorization, string id)
        {
             await GetOrchActiveStatusAsyncWithHttpInfo(accept, contentType, authorization, id);

        }

        /// <summary>
        /// Get the Service Orchestration active status for a Service Get a Service Orchestration&#x27;s active status.  A Service Orchestration allows you to set an active status based on whether an event will be evaluated against a service orchestration path (true) or service ruleset (false).  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.read&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> GetOrchActiveStatusAsyncWithHttpInfo (string accept, string contentType, string authorization, string id)
        {
            // verify the required parameter 'accept' is set
            if (accept == null)
                throw new ApiException(400, "Missing required parameter 'accept' when calling EventOrchestrationsApi->GetOrchActiveStatus");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400, "Missing required parameter 'contentType' when calling EventOrchestrationsApi->GetOrchActiveStatus");
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling EventOrchestrationsApi->GetOrchActiveStatus");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling EventOrchestrationsApi->GetOrchActiveStatus");

            var localVarPath = "/event_orchestrations/services/{id}/active";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.AddOrUpdate("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (accept != null) localVarHeaderParams.AddOrUpdate("Accept", this.Configuration.ApiClient.ParameterToString(accept)); // header parameter
            if (contentType != null) localVarHeaderParams.AddOrUpdate("Content-Type", this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (authorization != null) localVarHeaderParams.AddOrUpdate("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetOrchActiveStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Get the Router for a Global Event Orchestration Get a Global Event Orchestration&#x27;s Routing Rules.  An Orchestration Router allows you to create a set of Event Rules. The Router evaluates Events you send to this Orchestration against each of its rules, one at a time, and routes the event to a specific Service based on the first rule that matches. If an event doesn&#x27;t match any rules, it&#x27;ll be sent to service specified in as the &#x60;catch_all&#x60; or the \&quot;Unrouted\&quot; Orchestration if no service is specified.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns></returns>
        public void GetOrchPathRouter (string accept, string contentType, string authorization, string id)
        {
             GetOrchPathRouterWithHttpInfo(accept, contentType, authorization, id);
        }

        /// <summary>
        /// Get the Router for a Global Event Orchestration Get a Global Event Orchestration&#x27;s Routing Rules.  An Orchestration Router allows you to create a set of Event Rules. The Router evaluates Events you send to this Orchestration against each of its rules, one at a time, and routes the event to a specific Service based on the first rule that matches. If an event doesn&#x27;t match any rules, it&#x27;ll be sent to service specified in as the &#x60;catch_all&#x60; or the \&quot;Unrouted\&quot; Orchestration if no service is specified.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> GetOrchPathRouterWithHttpInfo (string accept, string contentType, string authorization, string id)
        {
            // verify the required parameter 'accept' is set
            if (accept == null)
                throw new ApiException(400, "Missing required parameter 'accept' when calling EventOrchestrationsApi->GetOrchPathRouter");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400, "Missing required parameter 'contentType' when calling EventOrchestrationsApi->GetOrchPathRouter");
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling EventOrchestrationsApi->GetOrchPathRouter");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling EventOrchestrationsApi->GetOrchPathRouter");

            var localVarPath = "/event_orchestrations/{id}/router";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.AddOrUpdate("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (accept != null) localVarHeaderParams.AddOrUpdate("Accept", this.Configuration.ApiClient.ParameterToString(accept)); // header parameter
            if (contentType != null) localVarHeaderParams.AddOrUpdate("Content-Type", this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (authorization != null) localVarHeaderParams.AddOrUpdate("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetOrchPathRouter", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Get the Router for a Global Event Orchestration Get a Global Event Orchestration&#x27;s Routing Rules.  An Orchestration Router allows you to create a set of Event Rules. The Router evaluates Events you send to this Orchestration against each of its rules, one at a time, and routes the event to a specific Service based on the first rule that matches. If an event doesn&#x27;t match any rules, it&#x27;ll be sent to service specified in as the &#x60;catch_all&#x60; or the \&quot;Unrouted\&quot; Orchestration if no service is specified.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task GetOrchPathRouterAsync (string accept, string contentType, string authorization, string id)
        {
             await GetOrchPathRouterAsyncWithHttpInfo(accept, contentType, authorization, id);

        }

        /// <summary>
        /// Get the Router for a Global Event Orchestration Get a Global Event Orchestration&#x27;s Routing Rules.  An Orchestration Router allows you to create a set of Event Rules. The Router evaluates Events you send to this Orchestration against each of its rules, one at a time, and routes the event to a specific Service based on the first rule that matches. If an event doesn&#x27;t match any rules, it&#x27;ll be sent to service specified in as the &#x60;catch_all&#x60; or the \&quot;Unrouted\&quot; Orchestration if no service is specified.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> GetOrchPathRouterAsyncWithHttpInfo (string accept, string contentType, string authorization, string id)
        {
            // verify the required parameter 'accept' is set
            if (accept == null)
                throw new ApiException(400, "Missing required parameter 'accept' when calling EventOrchestrationsApi->GetOrchPathRouter");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400, "Missing required parameter 'contentType' when calling EventOrchestrationsApi->GetOrchPathRouter");
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling EventOrchestrationsApi->GetOrchPathRouter");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling EventOrchestrationsApi->GetOrchPathRouter");

            var localVarPath = "/event_orchestrations/{id}/router";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.AddOrUpdate("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (accept != null) localVarHeaderParams.AddOrUpdate("Accept", this.Configuration.ApiClient.ParameterToString(accept)); // header parameter
            if (contentType != null) localVarHeaderParams.AddOrUpdate("Content-Type", this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (authorization != null) localVarHeaderParams.AddOrUpdate("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetOrchPathRouter", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Get the Service Orchestration for a Service Get a Service Orchestration.  A Service Orchestration allows you to create a set of Event Rules. The Service Orchestration evaluates Events sent to this Service against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Service Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.read&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns></returns>
        public void GetOrchPathService (string accept, string contentType, string authorization, string id)
        {
             GetOrchPathServiceWithHttpInfo(accept, contentType, authorization, id);
        }

        /// <summary>
        /// Get the Service Orchestration for a Service Get a Service Orchestration.  A Service Orchestration allows you to create a set of Event Rules. The Service Orchestration evaluates Events sent to this Service against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Service Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.read&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> GetOrchPathServiceWithHttpInfo (string accept, string contentType, string authorization, string id)
        {
            // verify the required parameter 'accept' is set
            if (accept == null)
                throw new ApiException(400, "Missing required parameter 'accept' when calling EventOrchestrationsApi->GetOrchPathService");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400, "Missing required parameter 'contentType' when calling EventOrchestrationsApi->GetOrchPathService");
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling EventOrchestrationsApi->GetOrchPathService");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling EventOrchestrationsApi->GetOrchPathService");

            var localVarPath = "/event_orchestrations/services/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.AddOrUpdate("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (accept != null) localVarHeaderParams.AddOrUpdate("Accept", this.Configuration.ApiClient.ParameterToString(accept)); // header parameter
            if (contentType != null) localVarHeaderParams.AddOrUpdate("Content-Type", this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (authorization != null) localVarHeaderParams.AddOrUpdate("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetOrchPathService", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Get the Service Orchestration for a Service Get a Service Orchestration.  A Service Orchestration allows you to create a set of Event Rules. The Service Orchestration evaluates Events sent to this Service against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Service Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.read&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task GetOrchPathServiceAsync (string accept, string contentType, string authorization, string id)
        {
             await GetOrchPathServiceAsyncWithHttpInfo(accept, contentType, authorization, id);

        }

        /// <summary>
        /// Get the Service Orchestration for a Service Get a Service Orchestration.  A Service Orchestration allows you to create a set of Event Rules. The Service Orchestration evaluates Events sent to this Service against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Service Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.read&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> GetOrchPathServiceAsyncWithHttpInfo (string accept, string contentType, string authorization, string id)
        {
            // verify the required parameter 'accept' is set
            if (accept == null)
                throw new ApiException(400, "Missing required parameter 'accept' when calling EventOrchestrationsApi->GetOrchPathService");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400, "Missing required parameter 'contentType' when calling EventOrchestrationsApi->GetOrchPathService");
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling EventOrchestrationsApi->GetOrchPathService");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling EventOrchestrationsApi->GetOrchPathService");

            var localVarPath = "/event_orchestrations/services/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.AddOrUpdate("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (accept != null) localVarHeaderParams.AddOrUpdate("Accept", this.Configuration.ApiClient.ParameterToString(accept)); // header parameter
            if (contentType != null) localVarHeaderParams.AddOrUpdate("Content-Type", this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (authorization != null) localVarHeaderParams.AddOrUpdate("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetOrchPathService", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Get the Unrouted Orchestration for a Global Event Orchestration Get a Global Event Orchestration&#x27;s Rules for Unrouted events.  An Unrouted Orchestration allows you to create a set of Event Rules that will be evaluated against all events that don&#x27;t match any rules in the Orchestration&#x27;s Router.  The Unrouted Orchestration evaluates Events sent to it against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Unrouted Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns></returns>
        public void GetOrchPathUnrouted (string accept, string contentType, string authorization, string id)
        {
             GetOrchPathUnroutedWithHttpInfo(accept, contentType, authorization, id);
        }

        /// <summary>
        /// Get the Unrouted Orchestration for a Global Event Orchestration Get a Global Event Orchestration&#x27;s Rules for Unrouted events.  An Unrouted Orchestration allows you to create a set of Event Rules that will be evaluated against all events that don&#x27;t match any rules in the Orchestration&#x27;s Router.  The Unrouted Orchestration evaluates Events sent to it against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Unrouted Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> GetOrchPathUnroutedWithHttpInfo (string accept, string contentType, string authorization, string id)
        {
            // verify the required parameter 'accept' is set
            if (accept == null)
                throw new ApiException(400, "Missing required parameter 'accept' when calling EventOrchestrationsApi->GetOrchPathUnrouted");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400, "Missing required parameter 'contentType' when calling EventOrchestrationsApi->GetOrchPathUnrouted");
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling EventOrchestrationsApi->GetOrchPathUnrouted");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling EventOrchestrationsApi->GetOrchPathUnrouted");

            var localVarPath = "/event_orchestrations/{id}/unrouted";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.AddOrUpdate("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (accept != null) localVarHeaderParams.AddOrUpdate("Accept", this.Configuration.ApiClient.ParameterToString(accept)); // header parameter
            if (contentType != null) localVarHeaderParams.AddOrUpdate("Content-Type", this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (authorization != null) localVarHeaderParams.AddOrUpdate("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetOrchPathUnrouted", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Get the Unrouted Orchestration for a Global Event Orchestration Get a Global Event Orchestration&#x27;s Rules for Unrouted events.  An Unrouted Orchestration allows you to create a set of Event Rules that will be evaluated against all events that don&#x27;t match any rules in the Orchestration&#x27;s Router.  The Unrouted Orchestration evaluates Events sent to it against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Unrouted Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task GetOrchPathUnroutedAsync (string accept, string contentType, string authorization, string id)
        {
             await GetOrchPathUnroutedAsyncWithHttpInfo(accept, contentType, authorization, id);

        }

        /// <summary>
        /// Get the Unrouted Orchestration for a Global Event Orchestration Get a Global Event Orchestration&#x27;s Rules for Unrouted events.  An Unrouted Orchestration allows you to create a set of Event Rules that will be evaluated against all events that don&#x27;t match any rules in the Orchestration&#x27;s Router.  The Unrouted Orchestration evaluates Events sent to it against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Unrouted Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> GetOrchPathUnroutedAsyncWithHttpInfo (string accept, string contentType, string authorization, string id)
        {
            // verify the required parameter 'accept' is set
            if (accept == null)
                throw new ApiException(400, "Missing required parameter 'accept' when calling EventOrchestrationsApi->GetOrchPathUnrouted");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400, "Missing required parameter 'contentType' when calling EventOrchestrationsApi->GetOrchPathUnrouted");
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling EventOrchestrationsApi->GetOrchPathUnrouted");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling EventOrchestrationsApi->GetOrchPathUnrouted");

            var localVarPath = "/event_orchestrations/{id}/unrouted";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.AddOrUpdate("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (accept != null) localVarHeaderParams.AddOrUpdate("Accept", this.Configuration.ApiClient.ParameterToString(accept)); // header parameter
            if (contentType != null) localVarHeaderParams.AddOrUpdate("Content-Type", this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (authorization != null) localVarHeaderParams.AddOrUpdate("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetOrchPathUnrouted", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Get an Orchestration Get a Global Event Orchestration.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>Object</returns>
        public Object GetOrchestration (string accept, string contentType, string authorization, string id)
        {
             ApiResponse<Object> localVarResponse = GetOrchestrationWithHttpInfo(accept, contentType, authorization, id);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get an Orchestration Get a Global Event Orchestration.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>ApiResponse of Object</returns>
        public ApiResponse< Object > GetOrchestrationWithHttpInfo (string accept, string contentType, string authorization, string id)
        {
            // verify the required parameter 'accept' is set
            if (accept == null)
                throw new ApiException(400, "Missing required parameter 'accept' when calling EventOrchestrationsApi->GetOrchestration");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400, "Missing required parameter 'contentType' when calling EventOrchestrationsApi->GetOrchestration");
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling EventOrchestrationsApi->GetOrchestration");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling EventOrchestrationsApi->GetOrchestration");

            var localVarPath = "/event_orchestrations/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.AddOrUpdate("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (accept != null) localVarHeaderParams.AddOrUpdate("Accept", this.Configuration.ApiClient.ParameterToString(accept)); // header parameter
            if (contentType != null) localVarHeaderParams.AddOrUpdate("Content-Type", this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (authorization != null) localVarHeaderParams.AddOrUpdate("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetOrchestration", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (string) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        /// Get an Orchestration Get a Global Event Orchestration.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>Task of Object</returns>
        public async System.Threading.Tasks.Task<Object> GetOrchestrationAsync (string accept, string contentType, string authorization, string id)
        {
             ApiResponse<Object> localVarResponse = await GetOrchestrationAsyncWithHttpInfo(accept, contentType, authorization, id);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get an Orchestration Get a Global Event Orchestration.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>Task of ApiResponse (Object)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> GetOrchestrationAsyncWithHttpInfo (string accept, string contentType, string authorization, string id)
        {
            // verify the required parameter 'accept' is set
            if (accept == null)
                throw new ApiException(400, "Missing required parameter 'accept' when calling EventOrchestrationsApi->GetOrchestration");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400, "Missing required parameter 'contentType' when calling EventOrchestrationsApi->GetOrchestration");
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling EventOrchestrationsApi->GetOrchestration");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling EventOrchestrationsApi->GetOrchestration");

            var localVarPath = "/event_orchestrations/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.AddOrUpdate("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (accept != null) localVarHeaderParams.AddOrUpdate("Accept", this.Configuration.ApiClient.ParameterToString(accept)); // header parameter
            if (contentType != null) localVarHeaderParams.AddOrUpdate("Content-Type", this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (authorization != null) localVarHeaderParams.AddOrUpdate("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetOrchestration", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (string) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        /// List Event Orchestrations List all Global Event Orchestrations on an Account.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="limit">The number of results per page. (optional)</param>
        /// <param name="offset">Offset to start pagination search results. (optional)</param>
        /// <param name="sortBy">Used to specify the field you wish to sort the results on. (optional, default to name:asc)</param>
        /// <returns>Object</returns>
        public Object ListEventOrchestrations (string accept, string contentType, string authorization, int? limit = null, int? offset = null, string sortBy = null)
        {
             ApiResponse<Object> localVarResponse = ListEventOrchestrationsWithHttpInfo(accept, contentType, authorization, limit, offset, sortBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List Event Orchestrations List all Global Event Orchestrations on an Account.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="limit">The number of results per page. (optional)</param>
        /// <param name="offset">Offset to start pagination search results. (optional)</param>
        /// <param name="sortBy">Used to specify the field you wish to sort the results on. (optional, default to name:asc)</param>
        /// <returns>ApiResponse of Object</returns>
        public ApiResponse< Object > ListEventOrchestrationsWithHttpInfo (string accept, string contentType, string authorization, int? limit = null, int? offset = null, string sortBy = null)
        {
            // verify the required parameter 'accept' is set
            if (accept == null)
                throw new ApiException(400, "Missing required parameter 'accept' when calling EventOrchestrationsApi->ListEventOrchestrations");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400, "Missing required parameter 'contentType' when calling EventOrchestrationsApi->ListEventOrchestrations");
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling EventOrchestrationsApi->ListEventOrchestrations");

            var localVarPath = "/event_orchestrations";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.AddOrUpdate("Accept", localVarHttpHeaderAccept);

            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (offset != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "offset", offset)); // query parameter
            if (sortBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sort_by", sortBy)); // query parameter
            if (accept != null) localVarHeaderParams.AddOrUpdate("Accept", this.Configuration.ApiClient.ParameterToString(accept)); // header parameter
            if (contentType != null) localVarHeaderParams.AddOrUpdate("Content-Type", this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (authorization != null) localVarHeaderParams.AddOrUpdate("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListEventOrchestrations", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (string) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        /// List Event Orchestrations List all Global Event Orchestrations on an Account.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="limit">The number of results per page. (optional)</param>
        /// <param name="offset">Offset to start pagination search results. (optional)</param>
        /// <param name="sortBy">Used to specify the field you wish to sort the results on. (optional, default to name:asc)</param>
        /// <returns>Task of Object</returns>
        public async System.Threading.Tasks.Task<Object> ListEventOrchestrationsAsync (string accept, string contentType, string authorization, int? limit = null, int? offset = null, string sortBy = null)
        {
             ApiResponse<Object> localVarResponse = await ListEventOrchestrationsAsyncWithHttpInfo(accept, contentType, authorization, limit, offset, sortBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List Event Orchestrations List all Global Event Orchestrations on an Account.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.read&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="limit">The number of results per page. (optional)</param>
        /// <param name="offset">Offset to start pagination search results. (optional)</param>
        /// <param name="sortBy">Used to specify the field you wish to sort the results on. (optional, default to name:asc)</param>
        /// <returns>Task of ApiResponse (Object)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> ListEventOrchestrationsAsyncWithHttpInfo (string accept, string contentType, string authorization, int? limit = null, int? offset = null, string sortBy = null)
        {
            // verify the required parameter 'accept' is set
            if (accept == null)
                throw new ApiException(400, "Missing required parameter 'accept' when calling EventOrchestrationsApi->ListEventOrchestrations");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400, "Missing required parameter 'contentType' when calling EventOrchestrationsApi->ListEventOrchestrations");
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling EventOrchestrationsApi->ListEventOrchestrations");

            var localVarPath = "/event_orchestrations";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.AddOrUpdate("Accept", localVarHttpHeaderAccept);

            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (offset != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "offset", offset)); // query parameter
            if (sortBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sort_by", sortBy)); // query parameter
            if (accept != null) localVarHeaderParams.AddOrUpdate("Accept", this.Configuration.ApiClient.ParameterToString(accept)); // header parameter
            if (contentType != null) localVarHeaderParams.AddOrUpdate("Content-Type", this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (authorization != null) localVarHeaderParams.AddOrUpdate("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListEventOrchestrations", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (string) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        /// Create an Orchestration Create a Global Event Orchestration.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Object</returns>
        public Object PostOrchestration (string accept, string contentType, string authorization, Object body = null)
        {
             ApiResponse<Object> localVarResponse = PostOrchestrationWithHttpInfo(accept, contentType, authorization, body);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create an Orchestration Create a Global Event Orchestration.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of Object</returns>
        public ApiResponse< Object > PostOrchestrationWithHttpInfo (string accept, string contentType, string authorization, Object body = null)
        {
            // verify the required parameter 'accept' is set
            if (accept == null)
                throw new ApiException(400, "Missing required parameter 'accept' when calling EventOrchestrationsApi->PostOrchestration");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400, "Missing required parameter 'contentType' when calling EventOrchestrationsApi->PostOrchestration");
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling EventOrchestrationsApi->PostOrchestration");

            var localVarPath = "/event_orchestrations";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.AddOrUpdate("Accept", localVarHttpHeaderAccept);

            if (accept != null) localVarHeaderParams.AddOrUpdate("Accept", this.Configuration.ApiClient.ParameterToString(accept)); // header parameter
            if (contentType != null) localVarHeaderParams.AddOrUpdate("Content-Type", this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (authorization != null) localVarHeaderParams.AddOrUpdate("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostOrchestration", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (string) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        /// Create an Orchestration Create a Global Event Orchestration.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of Object</returns>
        public async System.Threading.Tasks.Task<Object> PostOrchestrationAsync (string accept, string contentType, string authorization, Object body = null)
        {
             ApiResponse<Object> localVarResponse = await PostOrchestrationAsyncWithHttpInfo(accept, contentType, authorization, body);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create an Orchestration Create a Global Event Orchestration.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse (Object)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> PostOrchestrationAsyncWithHttpInfo (string accept, string contentType, string authorization, Object body = null)
        {
            // verify the required parameter 'accept' is set
            if (accept == null)
                throw new ApiException(400, "Missing required parameter 'accept' when calling EventOrchestrationsApi->PostOrchestration");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400, "Missing required parameter 'contentType' when calling EventOrchestrationsApi->PostOrchestration");
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling EventOrchestrationsApi->PostOrchestration");

            var localVarPath = "/event_orchestrations";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.AddOrUpdate("Accept", localVarHttpHeaderAccept);

            if (accept != null) localVarHeaderParams.AddOrUpdate("Accept", this.Configuration.ApiClient.ParameterToString(accept)); // header parameter
            if (contentType != null) localVarHeaderParams.AddOrUpdate("Content-Type", this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (authorization != null) localVarHeaderParams.AddOrUpdate("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PostOrchestration", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (string) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        /// Update the Service Orchestration active status for a Service Update a Service Orchestration&#x27;s active status.  A Service Orchestration allows you to set an active status based on whether an event will be evaluated against a service orchestration path (true) or service ruleset (false).  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.write&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns></returns>
        public void UpdateOrchActiveStatus (string accept, string contentType, string authorization, string id)
        {
             UpdateOrchActiveStatusWithHttpInfo(accept, contentType, authorization, id);
        }

        /// <summary>
        /// Update the Service Orchestration active status for a Service Update a Service Orchestration&#x27;s active status.  A Service Orchestration allows you to set an active status based on whether an event will be evaluated against a service orchestration path (true) or service ruleset (false).  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.write&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateOrchActiveStatusWithHttpInfo (string accept, string contentType, string authorization, string id)
        {
            // verify the required parameter 'accept' is set
            if (accept == null)
                throw new ApiException(400, "Missing required parameter 'accept' when calling EventOrchestrationsApi->UpdateOrchActiveStatus");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400, "Missing required parameter 'contentType' when calling EventOrchestrationsApi->UpdateOrchActiveStatus");
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling EventOrchestrationsApi->UpdateOrchActiveStatus");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling EventOrchestrationsApi->UpdateOrchActiveStatus");

            var localVarPath = "/event_orchestrations/services/{id}/active";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.AddOrUpdate("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (accept != null) localVarHeaderParams.AddOrUpdate("Accept", this.Configuration.ApiClient.ParameterToString(accept)); // header parameter
            if (contentType != null) localVarHeaderParams.AddOrUpdate("Content-Type", this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (authorization != null) localVarHeaderParams.AddOrUpdate("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateOrchActiveStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update the Service Orchestration active status for a Service Update a Service Orchestration&#x27;s active status.  A Service Orchestration allows you to set an active status based on whether an event will be evaluated against a service orchestration path (true) or service ruleset (false).  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.write&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateOrchActiveStatusAsync (string accept, string contentType, string authorization, string id)
        {
             await UpdateOrchActiveStatusAsyncWithHttpInfo(accept, contentType, authorization, id);

        }

        /// <summary>
        /// Update the Service Orchestration active status for a Service Update a Service Orchestration&#x27;s active status.  A Service Orchestration allows you to set an active status based on whether an event will be evaluated against a service orchestration path (true) or service ruleset (false).  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.write&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UpdateOrchActiveStatusAsyncWithHttpInfo (string accept, string contentType, string authorization, string id)
        {
            // verify the required parameter 'accept' is set
            if (accept == null)
                throw new ApiException(400, "Missing required parameter 'accept' when calling EventOrchestrationsApi->UpdateOrchActiveStatus");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400, "Missing required parameter 'contentType' when calling EventOrchestrationsApi->UpdateOrchActiveStatus");
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling EventOrchestrationsApi->UpdateOrchActiveStatus");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling EventOrchestrationsApi->UpdateOrchActiveStatus");

            var localVarPath = "/event_orchestrations/services/{id}/active";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.AddOrUpdate("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (accept != null) localVarHeaderParams.AddOrUpdate("Accept", this.Configuration.ApiClient.ParameterToString(accept)); // header parameter
            if (contentType != null) localVarHeaderParams.AddOrUpdate("Content-Type", this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (authorization != null) localVarHeaderParams.AddOrUpdate("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateOrchActiveStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update the Router for a Global Event Orchestration Update an Orchestration&#x27;s Routing Rules.  An Orchestration Router allows you to create a set of Event Rules. The Router evaluates Events you send to this Orchestration against each of its rules, one at a time, and routes the event to a specific Service based on the first rule that matches. If an event doesn&#x27;t match any rules, it&#x27;ll be sent to service specified in as the &#x60;catch_all&#x60; or the \&quot;Unrouted\&quot; Orchestration if no service is specified.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body">Updates to Orchestration Router details. Omitted rules and rule details are deleted. (optional)</param>
        /// <returns></returns>
        public void UpdateOrchPathRouter (string accept, string contentType, string authorization, string id, OrchestrationRouter body = null)
        {
             UpdateOrchPathRouterWithHttpInfo(accept, contentType, authorization, id, body);
        }

        /// <summary>
        /// Update the Router for a Global Event Orchestration Update an Orchestration&#x27;s Routing Rules.  An Orchestration Router allows you to create a set of Event Rules. The Router evaluates Events you send to this Orchestration against each of its rules, one at a time, and routes the event to a specific Service based on the first rule that matches. If an event doesn&#x27;t match any rules, it&#x27;ll be sent to service specified in as the &#x60;catch_all&#x60; or the \&quot;Unrouted\&quot; Orchestration if no service is specified.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body">Updates to Orchestration Router details. Omitted rules and rule details are deleted. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateOrchPathRouterWithHttpInfo (string accept, string contentType, string authorization, string id, OrchestrationRouter body = null)
        {
            // verify the required parameter 'accept' is set
            if (accept == null)
                throw new ApiException(400, "Missing required parameter 'accept' when calling EventOrchestrationsApi->UpdateOrchPathRouter");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400, "Missing required parameter 'contentType' when calling EventOrchestrationsApi->UpdateOrchPathRouter");
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling EventOrchestrationsApi->UpdateOrchPathRouter");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling EventOrchestrationsApi->UpdateOrchPathRouter");

            var localVarPath = "/event_orchestrations/{id}/router";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.AddOrUpdate("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (accept != null) localVarHeaderParams.AddOrUpdate("Accept", this.Configuration.ApiClient.ParameterToString(accept)); // header parameter
            if (contentType != null) localVarHeaderParams.AddOrUpdate("Content-Type", this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (authorization != null) localVarHeaderParams.AddOrUpdate("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateOrchPathRouter", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update the Router for a Global Event Orchestration Update an Orchestration&#x27;s Routing Rules.  An Orchestration Router allows you to create a set of Event Rules. The Router evaluates Events you send to this Orchestration against each of its rules, one at a time, and routes the event to a specific Service based on the first rule that matches. If an event doesn&#x27;t match any rules, it&#x27;ll be sent to service specified in as the &#x60;catch_all&#x60; or the \&quot;Unrouted\&quot; Orchestration if no service is specified.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body">Updates to Orchestration Router details. Omitted rules and rule details are deleted. (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateOrchPathRouterAsync (string accept, string contentType, string authorization, string id, OrchestrationRouter body = null)
        {
             await UpdateOrchPathRouterAsyncWithHttpInfo(accept, contentType, authorization, id, body);

        }

        /// <summary>
        /// Update the Router for a Global Event Orchestration Update an Orchestration&#x27;s Routing Rules.  An Orchestration Router allows you to create a set of Event Rules. The Router evaluates Events you send to this Orchestration against each of its rules, one at a time, and routes the event to a specific Service based on the first rule that matches. If an event doesn&#x27;t match any rules, it&#x27;ll be sent to service specified in as the &#x60;catch_all&#x60; or the \&quot;Unrouted\&quot; Orchestration if no service is specified.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body">Updates to Orchestration Router details. Omitted rules and rule details are deleted. (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UpdateOrchPathRouterAsyncWithHttpInfo (string accept, string contentType, string authorization, string id, OrchestrationRouter body = null)
        {
            // verify the required parameter 'accept' is set
            if (accept == null)
                throw new ApiException(400, "Missing required parameter 'accept' when calling EventOrchestrationsApi->UpdateOrchPathRouter");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400, "Missing required parameter 'contentType' when calling EventOrchestrationsApi->UpdateOrchPathRouter");
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling EventOrchestrationsApi->UpdateOrchPathRouter");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling EventOrchestrationsApi->UpdateOrchPathRouter");

            var localVarPath = "/event_orchestrations/{id}/router";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.AddOrUpdate("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (accept != null) localVarHeaderParams.AddOrUpdate("Accept", this.Configuration.ApiClient.ParameterToString(accept)); // header parameter
            if (contentType != null) localVarHeaderParams.AddOrUpdate("Content-Type", this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (authorization != null) localVarHeaderParams.AddOrUpdate("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateOrchPathRouter", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update the Service Orchestration for a Service Update a Service Orchestration.  A Service Orchestration allows you to create a set of Event Rules. The Service Orchestration evaluates Events sent to this Service against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Service Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.write&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body">Update Service Orchestration rules. Omitted rules and rule details are deleted. (optional)</param>
        /// <returns></returns>
        public void UpdateOrchPathService (string accept, string contentType, string authorization, string id, ServiceOrchestration body = null)
        {
             UpdateOrchPathServiceWithHttpInfo(accept, contentType, authorization, id, body);
        }

        /// <summary>
        /// Update the Service Orchestration for a Service Update a Service Orchestration.  A Service Orchestration allows you to create a set of Event Rules. The Service Orchestration evaluates Events sent to this Service against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Service Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.write&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body">Update Service Orchestration rules. Omitted rules and rule details are deleted. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateOrchPathServiceWithHttpInfo (string accept, string contentType, string authorization, string id, ServiceOrchestration body = null)
        {
            // verify the required parameter 'accept' is set
            if (accept == null)
                throw new ApiException(400, "Missing required parameter 'accept' when calling EventOrchestrationsApi->UpdateOrchPathService");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400, "Missing required parameter 'contentType' when calling EventOrchestrationsApi->UpdateOrchPathService");
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling EventOrchestrationsApi->UpdateOrchPathService");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling EventOrchestrationsApi->UpdateOrchPathService");

            var localVarPath = "/event_orchestrations/services/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.AddOrUpdate("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (accept != null) localVarHeaderParams.AddOrUpdate("Accept", this.Configuration.ApiClient.ParameterToString(accept)); // header parameter
            if (contentType != null) localVarHeaderParams.AddOrUpdate("Content-Type", this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (authorization != null) localVarHeaderParams.AddOrUpdate("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateOrchPathService", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update the Service Orchestration for a Service Update a Service Orchestration.  A Service Orchestration allows you to create a set of Event Rules. The Service Orchestration evaluates Events sent to this Service against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Service Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.write&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body">Update Service Orchestration rules. Omitted rules and rule details are deleted. (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateOrchPathServiceAsync (string accept, string contentType, string authorization, string id, ServiceOrchestration body = null)
        {
             await UpdateOrchPathServiceAsyncWithHttpInfo(accept, contentType, authorization, id, body);

        }

        /// <summary>
        /// Update the Service Orchestration for a Service Update a Service Orchestration.  A Service Orchestration allows you to create a set of Event Rules. The Service Orchestration evaluates Events sent to this Service against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Service Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;services.write&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body">Update Service Orchestration rules. Omitted rules and rule details are deleted. (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UpdateOrchPathServiceAsyncWithHttpInfo (string accept, string contentType, string authorization, string id, ServiceOrchestration body = null)
        {
            // verify the required parameter 'accept' is set
            if (accept == null)
                throw new ApiException(400, "Missing required parameter 'accept' when calling EventOrchestrationsApi->UpdateOrchPathService");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400, "Missing required parameter 'contentType' when calling EventOrchestrationsApi->UpdateOrchPathService");
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling EventOrchestrationsApi->UpdateOrchPathService");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling EventOrchestrationsApi->UpdateOrchPathService");

            var localVarPath = "/event_orchestrations/services/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.AddOrUpdate("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (accept != null) localVarHeaderParams.AddOrUpdate("Accept", this.Configuration.ApiClient.ParameterToString(accept)); // header parameter
            if (contentType != null) localVarHeaderParams.AddOrUpdate("Content-Type", this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (authorization != null) localVarHeaderParams.AddOrUpdate("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateOrchPathService", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update the Unrouted Orchestration for a Global Event Orchestration Update a Global Event Orchestration&#x27;s Rules for Unrouted events.  An Unrouted Orchestration allows you to create a set of Event Rules that will be evaluated against all events that don&#x27;t match any rules in the Orchestration&#x27;s Router.  The Unrouted Orchestration evaluates Events sent to it against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Unrouted Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body">Updates to Unrouted Orchestration rules. Omitted rules and rule details are deleted. (optional)</param>
        /// <returns></returns>
        public void UpdateOrchPathUnrouted (string accept, string contentType, string authorization, string id, OrchestrationUnrouted body = null)
        {
             UpdateOrchPathUnroutedWithHttpInfo(accept, contentType, authorization, id, body);
        }

        /// <summary>
        /// Update the Unrouted Orchestration for a Global Event Orchestration Update a Global Event Orchestration&#x27;s Rules for Unrouted events.  An Unrouted Orchestration allows you to create a set of Event Rules that will be evaluated against all events that don&#x27;t match any rules in the Orchestration&#x27;s Router.  The Unrouted Orchestration evaluates Events sent to it against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Unrouted Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body">Updates to Unrouted Orchestration rules. Omitted rules and rule details are deleted. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateOrchPathUnroutedWithHttpInfo (string accept, string contentType, string authorization, string id, OrchestrationUnrouted body = null)
        {
            // verify the required parameter 'accept' is set
            if (accept == null)
                throw new ApiException(400, "Missing required parameter 'accept' when calling EventOrchestrationsApi->UpdateOrchPathUnrouted");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400, "Missing required parameter 'contentType' when calling EventOrchestrationsApi->UpdateOrchPathUnrouted");
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling EventOrchestrationsApi->UpdateOrchPathUnrouted");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling EventOrchestrationsApi->UpdateOrchPathUnrouted");

            var localVarPath = "/event_orchestrations/{id}/unrouted";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.AddOrUpdate("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (accept != null) localVarHeaderParams.AddOrUpdate("Accept", this.Configuration.ApiClient.ParameterToString(accept)); // header parameter
            if (contentType != null) localVarHeaderParams.AddOrUpdate("Content-Type", this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (authorization != null) localVarHeaderParams.AddOrUpdate("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateOrchPathUnrouted", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update the Unrouted Orchestration for a Global Event Orchestration Update a Global Event Orchestration&#x27;s Rules for Unrouted events.  An Unrouted Orchestration allows you to create a set of Event Rules that will be evaluated against all events that don&#x27;t match any rules in the Orchestration&#x27;s Router.  The Unrouted Orchestration evaluates Events sent to it against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Unrouted Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body">Updates to Unrouted Orchestration rules. Omitted rules and rule details are deleted. (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateOrchPathUnroutedAsync (string accept, string contentType, string authorization, string id, OrchestrationUnrouted body = null)
        {
             await UpdateOrchPathUnroutedAsyncWithHttpInfo(accept, contentType, authorization, id, body);

        }

        /// <summary>
        /// Update the Unrouted Orchestration for a Global Event Orchestration Update a Global Event Orchestration&#x27;s Rules for Unrouted events.  An Unrouted Orchestration allows you to create a set of Event Rules that will be evaluated against all events that don&#x27;t match any rules in the Orchestration&#x27;s Router.  The Unrouted Orchestration evaluates Events sent to it against each of its rules, beginning with the rules in the \&quot;start\&quot; set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Unrouted Orchestration for further processing.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body">Updates to Unrouted Orchestration rules. Omitted rules and rule details are deleted. (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UpdateOrchPathUnroutedAsyncWithHttpInfo (string accept, string contentType, string authorization, string id, OrchestrationUnrouted body = null)
        {
            // verify the required parameter 'accept' is set
            if (accept == null)
                throw new ApiException(400, "Missing required parameter 'accept' when calling EventOrchestrationsApi->UpdateOrchPathUnrouted");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400, "Missing required parameter 'contentType' when calling EventOrchestrationsApi->UpdateOrchPathUnrouted");
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling EventOrchestrationsApi->UpdateOrchPathUnrouted");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling EventOrchestrationsApi->UpdateOrchPathUnrouted");

            var localVarPath = "/event_orchestrations/{id}/unrouted";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.AddOrUpdate("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (accept != null) localVarHeaderParams.AddOrUpdate("Accept", this.Configuration.ApiClient.ParameterToString(accept)); // header parameter
            if (contentType != null) localVarHeaderParams.AddOrUpdate("Content-Type", this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (authorization != null) localVarHeaderParams.AddOrUpdate("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateOrchPathUnrouted", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update an Orchestration Update a Global Event Orchestration.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Object</returns>
        public Object UpdateOrchestration (string accept, string contentType, string authorization, string id, Object body = null)
        {
             ApiResponse<Object> localVarResponse = UpdateOrchestrationWithHttpInfo(accept, contentType, authorization, id, body);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update an Orchestration Update a Global Event Orchestration.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of Object</returns>
        public ApiResponse< Object > UpdateOrchestrationWithHttpInfo (string accept, string contentType, string authorization, string id, Object body = null)
        {
            // verify the required parameter 'accept' is set
            if (accept == null)
                throw new ApiException(400, "Missing required parameter 'accept' when calling EventOrchestrationsApi->UpdateOrchestration");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400, "Missing required parameter 'contentType' when calling EventOrchestrationsApi->UpdateOrchestration");
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling EventOrchestrationsApi->UpdateOrchestration");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling EventOrchestrationsApi->UpdateOrchestration");

            var localVarPath = "/event_orchestrations/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.AddOrUpdate("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (accept != null) localVarHeaderParams.AddOrUpdate("Accept", this.Configuration.ApiClient.ParameterToString(accept)); // header parameter
            if (contentType != null) localVarHeaderParams.AddOrUpdate("Content-Type", this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (authorization != null) localVarHeaderParams.AddOrUpdate("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateOrchestration", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (string) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        /// Update an Orchestration Update a Global Event Orchestration.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of Object</returns>
        public async System.Threading.Tasks.Task<Object> UpdateOrchestrationAsync (string accept, string contentType, string authorization, string id, Object body = null)
        {
             ApiResponse<Object> localVarResponse = await UpdateOrchestrationAsyncWithHttpInfo(accept, contentType, authorization, id, body);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update an Orchestration Update a Global Event Orchestration.  Global Event Orchestrations allow you define a set of Event Rules, so that when you ingest events using the Orchestration&#x27;s Routing Key your events will be routed to the correct Service, based on the event&#x27;s content.  For more information see the [API Concepts Document](../../api-reference/ZG9jOjI3NDc5Nzc-api-concepts#event-orchestrations)  Scoped OAuth requires: &#x60;event_orchestrations.write&#x60; 
        /// </summary>
        /// <exception cref="PagerDuty.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accept">The &#x60;Accept&#x60; header is used as a versioning header.</param>
        /// <param name="contentType"></param>
        /// <param name="authorization">The &#x60;Authorization&#x60; header is used as a versioning header.</param>
        /// <param name="id">The ID of the resource.</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse (Object)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UpdateOrchestrationAsyncWithHttpInfo (string accept, string contentType, string authorization, string id, Object body = null)
        {
            // verify the required parameter 'accept' is set
            if (accept == null)
                throw new ApiException(400, "Missing required parameter 'accept' when calling EventOrchestrationsApi->UpdateOrchestration");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400, "Missing required parameter 'contentType' when calling EventOrchestrationsApi->UpdateOrchestration");
            // verify the required parameter 'authorization' is set
            if (authorization == null)
                throw new ApiException(400, "Missing required parameter 'authorization' when calling EventOrchestrationsApi->UpdateOrchestration");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling EventOrchestrationsApi->UpdateOrchestration");

            var localVarPath = "/event_orchestrations/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.AddOrUpdate("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (accept != null) localVarHeaderParams.AddOrUpdate("Accept", this.Configuration.ApiClient.ParameterToString(accept)); // header parameter
            if (contentType != null) localVarHeaderParams.AddOrUpdate("Content-Type", this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (authorization != null) localVarHeaderParams.AddOrUpdate("Authorization", this.Configuration.ApiClient.ParameterToString(authorization)); // header parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateOrchestration", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (string) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

    }
}
